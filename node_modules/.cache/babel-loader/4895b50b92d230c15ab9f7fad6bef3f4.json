{"ast":null,"code":"/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5\n};\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\"Please enable Contract data on the Ethereum app Settings\");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\n\n\nexport default class Eth {\n  constructor(transport, scrambleKey = \"w0w\") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, [\"getAddress\", \"provideERC20TokenInformation\", \"signTransaction\", \"signPersonalMessage\", \"getAppConfiguration\", \"signEIP712HashedMessage\", \"starkGetPublicKey\", \"starkSignOrder\", \"starkSignOrder_v2\", \"starkSignTransfer\", \"starkSignTransfer_v2\", \"starkProvideQuantum\", \"starkProvideQuantum_v2\", \"starkUnsafeSign\", \"eth2GetPublicKey\", \"eth2SetWithdrawalIndex\"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n      result.address = \"0x\" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString(\"ascii\");\n\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString(\"hex\");\n      }\n\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  provideERC20TokenInformation({\n    data\n  }) {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n\n\n  signTransaction(path, rawTxHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response; // Check if the TX is encoded following EIP 155\n\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2 + 35).toString(16).slice(0, -2); // Drop the low byte, that comes from the ledger.\n\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signPersonalMessage(path, messageHex) {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return foreach(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n  })\n   */\n\n\n  signEIP712HashedMessage(path, domainSeparatorHex, hashStructMessageHex) {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport.send(0xe0, 0x0c, 0x00, 0x00, buffer).then(response => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  starkGetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      return response.slice(0, response.length - 2);\n    });\n  }\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder(path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder_v2(path, sourceTokenAddress, sourceQuantizationType, sourceQuantization, sourceMintableBlobOrTokenId, destinationTokenAddress, destinationQuantizationType, destinationQuantization, destinationMintableBlobOrTokenId, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid source quantization type=\" + sourceQuantizationType);\n    }\n\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignOrderv2 invalid destination quantization type=\" + destinationQuantizationType);\n    }\n\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 1 + 20 + 32 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (sourceQuantization) {\n      Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (destinationQuantization) {\n      Buffer.from(destinationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x03, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignTransfer(path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n\n\n  starkSignTransfer_v2(path, transferTokenAddress, transferQuantizationType, transferQuantization, transferMintableBlobOrTokenId, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp, conditionalTransferAddress, conditionalTransferFact) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(conditionalTransferAddress);\n\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkSignTransferv2 invalid quantization type=\" + transferQuantizationType);\n    }\n\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 1 + 20 + 32 + 32 + 32 + 4 + 4 + 8 + 4 + 4 + (conditionalTransferAddressHex ? 32 + 20 : 0), 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (transferQuantization) {\n      Buffer.from(transferQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(conditionalTransferFact.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x04, conditionalTransferAddressHex ? 0x05 : 0x04, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  starkProvideQuantum(operationContract, operationQuantization) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n\n\n  starkProvideQuantum_v2(operationContract, operationQuantizationType, operationQuantization, operationMintableBlobOrTokenId) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\"eth.starkProvideQuantumV2 invalid quantization type=\" + operationQuantizationType);\n    }\n\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n\n    if (operationQuantization) {\n      Buffer.from(operationQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    offset += 32;\n\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"), \"hex\").copy(buffer, offset);\n    }\n\n    return this.transport.send(0xf0, 0x08, starkQuantizationTypeMap[operationQuantizationType], 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n\n\n  starkUnsafeSign(path, hash) {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport.send(0xf0, 0x0a, 0x00, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n\n\n  eth2GetPublicKey(path, boolDisplay) {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      let result = {};\n      result.publicKey = response.slice(0, -2).toString(\"hex\");\n      return result;\n    });\n  }\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n\n\n  eth2SetWithdrawalIndex(withdrawalIndex) {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting ETH 2\n        return false;\n      }\n\n      throw e;\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/Eth.js"],"names":["starkQuantizationTypeMap","eth","erc20","erc721","erc20mintable","erc721mintable","Buffer","str","hexBuffer","remapTransactionRelatedErrors","e","transport","constructor","scrambleKey","getAddress","paths","splitPath","buffer","boolDisplay","boolChaincode","response","result","publicKeyLength","addressLength","provideERC20TokenInformation","data","signTransaction","offset","rawTx","toSend","rlpTx","decode","rlpOffset","chainIdPrefix","rlpVrs","encode","chainIdSrc","chainIdBuf","maxChunkSize","chunkSize","i","apduResponse","v","r","s","getAppConfiguration","signPersonalMessage","message","signEIP712HashedMessage","domainSeparator","hashStruct","starkGetPublicKey","starkSignOrder","sourceTokenAddressHex","maybeHexBuffer","destinationTokenAddressHex","sourceQuantization","destinationQuantization","amountSell","amountBuy","starkSignOrder_v2","sourceQuantizationType","destinationQuantizationType","sourceMintableBlobOrTokenId","destinationMintableBlobOrTokenId","starkSignTransfer","transferTokenAddressHex","targetPublicKeyHex","transferQuantization","amountTransfer","starkSignTransfer_v2","conditionalTransferAddressHex","transferQuantizationType","transferMintableBlobOrTokenId","conditionalTransferFact","starkProvideQuantum","operationContractHex","operationQuantization","starkProvideQuantum_v2","operationQuantizationType","operationMintableBlobOrTokenId","starkUnsafeSign","hashHex","eth2GetPublicKey","eth2SetWithdrawalIndex"],"mappings":"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","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach } from \"./utils\";\nimport { EthAppPleaseEnableContractData } from \"@ledgerhq/errors\";\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { BigNumber } from \"bignumber.js\";\nimport { encode, decode } from \"rlp\";\n\nexport type StarkQuantizationType =\n  | \"eth\"\n  | \"erc20\"\n  | \"erc721\"\n  | \"erc20mintable\"\n  | \"erc721mintable\";\n\nconst starkQuantizationTypeMap = {\n  eth: 1,\n  erc20: 2,\n  erc721: 3,\n  erc20mintable: 4,\n  erc721mintable: 5,\n};\n\nfunction hexBuffer(str: string): Buffer {\n  return Buffer.from(str.startsWith(\"0x\") ? str.slice(2) : str, \"hex\");\n}\n\nfunction maybeHexBuffer(str: ?string): ?Buffer {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = (e) => {\n  if (e && e.statusCode === 0x6a80) {\n    return new EthAppPleaseEnableContractData(\n      \"Please enable Contract data on the Ethereum app Settings\"\n    );\n  }\n  return e;\n};\n\n/**\n * Ethereum API\n *\n * @example\n * import Eth from \"@ledgerhq/hw-app-eth\";\n * const eth = new Eth(transport)\n */\nexport default class Eth {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"w0w\") {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"provideERC20TokenInformation\",\n        \"signTransaction\",\n        \"signPersonalMessage\",\n        \"getAppConfiguration\",\n        \"signEIP712HashedMessage\",\n        \"starkGetPublicKey\",\n        \"starkSignOrder\",\n        \"starkSignOrder_v2\",\n        \"starkSignTransfer\",\n        \"starkSignTransfer_v2\",\n        \"starkProvideQuantum\",\n        \"starkProvideQuantum_v2\",\n        \"starkUnsafeSign\",\n        \"eth2GetPublicKey\",\n        \"eth2SetWithdrawalIndex\",\n      ],\n      scrambleKey\n    );\n  }\n\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress(\"44'/60'/0'/0/0\").then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean,\n    boolChaincode?: boolean\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00,\n        boolChaincode ? 0x01 : 0x00,\n        buffer\n      )\n      .then((response) => {\n        let result = {};\n        let publicKeyLength = response[0];\n        let addressLength = response[1 + publicKeyLength];\n        result.publicKey = response\n          .slice(1, 1 + publicKeyLength)\n          .toString(\"hex\");\n        result.address =\n          \"0x\" +\n          response\n            .slice(\n              1 + publicKeyLength + 1,\n              1 + publicKeyLength + 1 + addressLength\n            )\n            .toString(\"ascii\");\n        if (boolChaincode) {\n          result.chainCode = response\n            .slice(\n              1 + publicKeyLength + 1 + addressLength,\n              1 + publicKeyLength + 1 + addressLength + 32\n            )\n            .toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from \"erc20.js\" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from \"@ledgerhq/hw-app-eth/erc20\"\n   * const zrxInfo = byContractAddress(\"0xe41d2489571d322189246dafa5ebde1f4699f498\")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n  provideERC20TokenInformation({ data }: { data: Buffer }): Promise<boolean> {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it's fine to assume it worked.\n          // we return a flag to know if the call was effective or not\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction(\"44'/60'/0'/0/0\", \"e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080\").then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxHex: string\n  ): Promise<{\n    s: string,\n    v: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, \"hex\");\n    let toSend = [];\n    let response;\n    // Check if the TX is encoded following EIP 155\n    let rlpTx = decode(rawTx);\n    let rlpOffset = 0;\n    let chainIdPrefix = \"\";\n    if (rlpTx.length > 6) {\n      let rlpVrs = encode(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n      const chainIdSrc = rlpTx[6];\n      const chainIdBuf = Buffer.alloc(4);\n      chainIdSrc.copy(chainIdBuf, 4 - chainIdSrc.length);\n      chainIdPrefix = (chainIdBuf.readUInt32BE(0) * 2 + 35)\n        .toString(16)\n        .slice(0, -2); // Drop the low byte, that comes from the ledger.\n      if (chainIdPrefix.length % 2 === 1) {\n        chainIdPrefix = \"0\" + chainIdPrefix;\n      }\n    }\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn't end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(\n      () => {\n        const v = chainIdPrefix + response.slice(0, 1).toString(\"hex\");\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      },\n      (e) => {\n        throw remapTransactionRelatedErrors(e);\n      }\n    );\n  }\n\n  /**\n   */\n  getAppConfiguration(): Promise<{\n    arbitraryDataEnabled: number,\n    erc20ProvisioningNecessary: number,\n    starkEnabled: number,\n    starkv2Supported: number,\n    version: string,\n  }> {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then((response) => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.starkv2Supported = response[0] & 0x08;\n      result.version = \"\" + response[1] + \".\" + response[2] + \".\" + response[3];\n      return result;\n    });\n  }\n\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\neth.signPersonalMessage(\"44'/60'/0'/0/0\", Buffer.from(\"test\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signPersonalMessage(\n    path: string,\n    messageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, \"hex\");\n    let toSend = [];\n    let response;\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize =\n        offset + maxChunkSize > message.length\n          ? message.length - offset\n          : maxChunkSize;\n      let buffer = Buffer.alloc(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(\n          buffer,\n          1 + 4 * paths.length + 4,\n          offset,\n          offset + chunkSize\n        );\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then((apduResponse) => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString(\"hex\");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n      return { v, r, s };\n    });\n  }\n\n  /**\n  * Sign a prepared message following web3.eth.signTypedData specification. The host computes the domain separator and hashStruct(message)\n  * @example\n  eth.signEIP712HashedMessage(\"44'/60'/0'/0/0\", Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\").toString(\"hex\"), Buffer.from(\"0202020202020202020202020202020202020202020202020202020202020202\").toString(\"hex\")).then(result => {\n  var v = result['v'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = \"0\" + v;\n  }\n  console.log(\"Signature 0x\" + result['r'] + result['s'] + v);\n})\n   */\n  signEIP712HashedMessage(\n    path: string,\n    domainSeparatorHex: string,\n    hashStructMessageHex: string\n  ): Promise<{\n    v: number,\n    s: string,\n    r: string,\n  }> {\n    const domainSeparator = hexBuffer(domainSeparatorHex);\n    const hashStruct = hexBuffer(hashStructMessageHex);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32 + 32, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    domainSeparator.copy(buffer, offset);\n    offset += 32;\n    hashStruct.copy(buffer, offset);\n    return this.transport\n      .send(0xe0, 0x0c, 0x00, 0x00, buffer)\n      .then((response) => {\n        const v = response[0];\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { v, r, s };\n      });\n  }\n\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n  starkGetPublicKey(path: string, boolDisplay?: boolean): Promise<Buffer> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        return response.slice(0, response.length - 2);\n      });\n  }\n\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantization: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantization: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 32;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      destinationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x01, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark order using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantizationType quantization type used for the source token\n   * @option sourceQuantization quantization used for the source token (not present for erc 721 or mintable erc 721)\n   * @option sourceMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantizationType quantization type used for the destination token\n   * @option destinationQuantization quantization used for the destination token (not present for erc 721 or mintable erc 721)\n   * @option destinationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignOrder_v2(\n    path: string,\n    sourceTokenAddress?: string,\n    sourceQuantizationType: StarkQuantizationType,\n    sourceQuantization?: BigNumber,\n    sourceMintableBlobOrTokenId?: BigNumber,\n    destinationTokenAddress?: string,\n    destinationQuantizationType: StarkQuantizationType,\n    destinationQuantization?: BigNumber,\n    destinationMintableBlobOrTokenId?: BigNumber,\n    sourceVault: number,\n    destinationVault: number,\n    amountSell: BigNumber,\n    amountBuy: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    if (!(sourceQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid source quantization type=\" +\n          sourceQuantizationType\n      );\n    }\n    if (!(destinationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignOrderv2 invalid destination quantization type=\" +\n          destinationQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        1 +\n        20 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        8 +\n        4 +\n        4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[sourceQuantizationType];\n    offset++;\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (sourceQuantization) {\n      Buffer.from(\n        sourceQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (sourceMintableBlobOrTokenId) {\n      Buffer.from(\n        sourceMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer[offset] = starkQuantizationTypeMap[destinationQuantizationType];\n    offset++;\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (destinationQuantization) {\n      Buffer.from(\n        destinationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (destinationMintableBlobOrTokenId) {\n      Buffer.from(\n        destinationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x03, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n  starkSignTransfer(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantization: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4,\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    Buffer.from(\n      transferQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport\n      .send(0xf0, 0x04, 0x02, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * sign a Stark transfer or conditional transfer using the Starkex V2 protocol\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantizationType quantization type used for the token to be transferred\n   * @option transferQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option transferMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) associated to the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @option conditionalTransferAddress onchain address of the condition for a conditional transfer\n   * @option conditionalTransferFact fact associated to the condition for a conditional transfer\n   * @return the signature\n   */\n  starkSignTransfer_v2(\n    path: string,\n    transferTokenAddress?: string,\n    transferQuantizationType: StarkQuantizationType,\n    transferQuantization?: BigNumber,\n    transferMintableBlobOrTokenId?: BigNumber,\n    targetPublicKey: string,\n    sourceVault: number,\n    destinationVault: number,\n    amountTransfer: BigNumber,\n    nonce: number,\n    timestamp: number,\n    conditionalTransferAddress?: string,\n    conditionalTransferFact?: BigNumber\n  ): Promise<Buffer> {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    const conditionalTransferAddressHex = maybeHexBuffer(\n      conditionalTransferAddress\n    );\n    if (!(transferQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkSignTransferv2 invalid quantization type=\" +\n          transferQuantizationType\n      );\n    }\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(\n      1 +\n        paths.length * 4 +\n        1 +\n        20 +\n        32 +\n        32 +\n        32 +\n        4 +\n        4 +\n        8 +\n        4 +\n        4 +\n        (conditionalTransferAddressHex ? 32 + 20 : 0),\n      0\n    );\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    buffer[offset] = starkQuantizationTypeMap[transferQuantizationType];\n    offset++;\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (transferQuantization) {\n      Buffer.from(\n        transferQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (transferMintableBlobOrTokenId) {\n      Buffer.from(\n        transferMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, \"0\"), \"hex\").copy(\n      buffer,\n      offset\n    );\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    if (conditionalTransferAddressHex && conditionalTransferFact) {\n      offset += 4;\n      Buffer.from(\n        conditionalTransferFact.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n      offset += 32;\n      conditionalTransferAddressHex.copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x04,\n        conditionalTransferAddressHex ? 0x05 : 0x04,\n        0x00,\n        buffer\n      )\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n  starkProvideQuantum(\n    operationContract?: string,\n    operationQuantization: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n    Buffer.from(\n      operationQuantization.toString(16).padStart(64, \"0\"),\n      \"hex\"\n    ).copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting Stark extensions\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call using the Starkex V2 protocol\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantizationType quantization type of the token to be transferred\n   * @option operationQuantization quantization used for the token to be transferred (not present for erc 721 or mintable erc 721)\n   * @option operationMintableBlobOrTokenId mintable blob (mintable erc 20 / mintable erc 721) or token id (erc 721) of the token to be transferred\n   */\n  starkProvideQuantum_v2(\n    operationContract?: string,\n    operationQuantizationType: StarkQuantizationType,\n    operationQuantization?: BigNumber,\n    operationMintableBlobOrTokenId?: BigNumber\n  ): Promise<boolean> {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    if (!(operationQuantizationType in starkQuantizationTypeMap)) {\n      throw new Error(\n        \"eth.starkProvideQuantumV2 invalid quantization type=\" +\n          operationQuantizationType\n      );\n    }\n    let buffer = Buffer.alloc(20 + 32 + 32, 0);\n    let offset = 0;\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, offset);\n    }\n    offset += 20;\n    if (operationQuantization) {\n      Buffer.from(\n        operationQuantization.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    offset += 32;\n    if (operationMintableBlobOrTokenId) {\n      Buffer.from(\n        operationMintableBlobOrTokenId.toString(16).padStart(64, \"0\"),\n        \"hex\"\n      ).copy(buffer, offset);\n    }\n    return this.transport\n      .send(\n        0xf0,\n        0x08,\n        starkQuantizationTypeMap[operationQuantizationType],\n        0x00,\n        buffer\n      )\n      .then(\n        () => true,\n        (e) => {\n          if (e && e.statusCode === 0x6d00) {\n            // this case happen for ETH application versions not supporting Stark extensions\n            return false;\n          }\n          throw e;\n        }\n      );\n  }\n\n  /**\n   * sign the given hash over the Stark curve\n   * It is intended for speed of execution in case an unknown Stark model is pushed and should be avoided as much as possible.\n   * @param path a path in BIP 32 format\n   * @param hash hexadecimal hash to sign\n   * @return the signature\n   */\n  starkUnsafeSign(path: string, hash: string): Promise<Buffer> {\n    const hashHex = hexBuffer(hash);\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 32);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n    hashHex.copy(buffer, offset);\n    return this.transport\n      .send(0xf0, 0x0a, 0x00, 0x00, buffer)\n      .then((response) => {\n        const r = response.slice(1, 1 + 32).toString(\"hex\");\n        const s = response.slice(1 + 32, 1 + 32 + 32).toString(\"hex\");\n        return { r, s };\n      });\n  }\n\n  /**\n   * get an Ethereum 2 BLS-12 381 public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return an object with a publicKey\n   * @example\n   * eth.eth2GetPublicKey(\"12381/3600/0/0\").then(o => o.publicKey)\n   */\n  eth2GetPublicKey(\n    path: string,\n    boolDisplay?: boolean\n  ): Promise<{\n    publicKey: string,\n  }> {\n    let paths = splitPath(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(0xe0, 0x0e, boolDisplay ? 0x01 : 0x00, 0x00, buffer)\n      .then((response) => {\n        let result = {};\n        result.publicKey = response.slice(0, -2).toString(\"hex\");\n        return result;\n      });\n  }\n\n  /**\n   * Set the index of a Withdrawal key used as withdrawal credentials in an ETH 2 deposit contract call signature\n   *\n   * It shall be run before the ETH 2 deposit transaction is signed. If not called, the index is set to 0\n   *\n   * @param withdrawalIndex index path in the EIP 2334 path m/12381/3600/withdrawalIndex/0\n   * @return True if the method was executed successfully\n   */\n  eth2SetWithdrawalIndex(withdrawalIndex: number): Promise<boolean> {\n    let buffer = Buffer.alloc(4, 0);\n    buffer.writeUInt32BE(withdrawalIndex, 0);\n    return this.transport.send(0xe0, 0x10, 0x00, 0x00, buffer).then(\n      () => true,\n      (e) => {\n        if (e && e.statusCode === 0x6d00) {\n          // this case happen for ETH application versions not supporting ETH 2\n          return false;\n        }\n        throw e;\n      }\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}