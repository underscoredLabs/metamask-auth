{"ast":null,"code":"// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst BN = require('bignumber.js');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst constants = require('./constants');\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst rlp = require('rlp-browser');\n\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function (input) {\n  if (!input.payload || !input.protocol || !input.signerPath) throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input,\n    // Save the input for later\n    msg: null // Save the buffered message for later\n\n  };\n\n  if (input.protocol === 'signPersonal') {\n    const L = (input.signerPath.length + 1) * 4 + input.ethMaxMsgSz + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0);\n    off += 1;\n    req.payload.writeUInt32LE(input.signerPath.length, off);\n    off += 4;\n\n    for (let i = 0; i < input.signerPath.length; i++) {\n      req.payload.writeUInt32LE(input.signerPath[i], off);\n      off += 4;\n    } // Write the payload buffer. The payload can come in either as a buffer or as a string\n\n\n    let payload = input.payload; // Determine if this is a hex string\n\n    let displayHex = false;\n\n    if (typeof input.payload === 'string') {\n      if (input.payload.slice(0, 2) === '0x') {\n        payload = ensureHexBuffer(input.payload);\n        displayHex = true === isHexStr(input.payload.slice(2));\n      } else {\n        if (false === latticeCanDisplayStr(input.payload)) throw new Error('Currently, the Lattice can only display ASCII strings.');\n        payload = Buffer.from(input.payload);\n      }\n    } else if (typeof input.displayHex === 'boolean') {\n      // If this is a buffer and the user has specified whether or not this\n      // is a hex buffer with the optional argument, write that\n      displayHex = input.displayHex;\n    } // Write the payload and metadata into our buffer\n\n\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off);\n    off += 1;\n    req.payload.writeUInt16LE(payload.length, off);\n    off += 2; // Make sure we didn't run past the max size\n\n    if (payload.length > input.ethMaxMsgSz) throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${input.ethMaxMsgSz}`);\n    payload.copy(req.payload, off);\n    return req;\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n};\n\nexports.validateEthereumMsgResponse = function (res, req) {\n  const {\n    signer,\n    sig\n  } = res;\n  const {\n    input,\n    msg\n  } = req;\n\n  if (input.protocol === 'signPersonal') {\n    const prefix = Buffer.from(`\\u0019Ethereum Signed Message:\\n${msg.length.toString()}`, 'utf-8');\n    return addRecoveryParam(Buffer.concat([prefix, msg]), sig, signer);\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n};\n\nexports.buildEthereumTxRequest = function (data) {\n  try {\n    let {\n      chainId = 1\n    } = data;\n    const {\n      signerPath,\n      eip155 = null,\n      ethMaxDataSz\n    } = data; // Sanity checks:\n    // There are a handful of named chains we allow the user to reference (`chainIds`)\n    // Custom chainIDs should be either numerical or hex strings\n\n    if (typeof chainId !== 'number' && isValidChainIdHexNumStr(chainId) === false) chainId = chainIds[chainId]; // If this was not a custom chainID and we cannot find the name of it, exit\n\n    if (!chainId) throw new Error('Unsupported chain ID or name'); // Sanity check on signePath\n\n    if (!signerPath || signerPath.length !== 5) throw new Error('Please provider full signer path (`signerPath`)'); // Determine if we should use EIP155 given the chainID.\n    // If we are explicitly told to use eip155, we will use it. Otherwise,\n    // we will look up if the specified chainId is associated with a chain\n    // that does not use EIP155 by default. Note that most do use EIP155.\n\n    let useEIP155 = chainUsesEIP155(chainId);\n    if (eip155 !== null && typeof eip155 === 'boolean') useEIP155 = eip155; // Hack for metamask, which sends value=null for 0 ETH transactions\n\n    if (!data.value) data.value = 0; //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n    // Ensure all fields are 0x-prefixed hex strings\n\n    const rawTx = []; // Build the transaction buffer array\n\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes); // Add empty v,r,s values\n\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n\n      rawTx.push(ensureHexBuffer(null)); // r\n\n      rawTx.push(ensureHexBuffer(null)); // s\n    } //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n\n\n    const ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params\n\n    const txReqPayload = Buffer.alloc(ethMaxDataSz + ETH_TX_NON_DATA_SZ);\n    let off = 0; // 1. EIP155 switch and chainID\n    //------------------\n\n    txReqPayload.writeUInt8(Number(useEIP155), off);\n    off++; // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger\n    // chainID values. To account for these, we will put the chainID into the `data` buffer if it\n    // is >=255. Values up to UINT64_MAX will be allowed.\n\n    let chainIdBuf;\n    let chainIdBufSz = 0;\n\n    if (useChainIdBuffer(chainId) === true) {\n      chainIdBuf = getChainIdBuf(chainId);\n      chainIdBufSz = chainIdBuf.length;\n      if (chainIdBufSz > constants.MAX_CHAIN_ID_BYTES) throw new Error('ChainID provided is too large.'); // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer\n\n      txReqPayload.writeUInt8(constants.HANDLE_LARGER_CHAIN_ID, off);\n      off++;\n    } else {\n      // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer\n      chainIdBuf = ensureHexBuffer(chainId);\n      if (chainIdBuf.length !== 1) throw new Error('Error parsing chainID');\n      chainIdBuf.copy(txReqPayload, off);\n      off += chainIdBuf.length;\n    } // 2. BIP44 Path\n    //------------------\n    // First write the number of indices in this path (will probably always be 5, but\n    // we want to keep this extensible)\n\n\n    txReqPayload.writeUInt32LE(signerPath.length, off);\n    off += 4;\n\n    for (let i = 0; i < signerPath.length; i++) {\n      txReqPayload.writeUInt32LE(signerPath[i], off);\n      off += 4;\n    } // 3. ETH TX request data\n    //------------------\n\n\n    txReqPayload.writeUInt32BE(data.nonce, off);\n    off += 4;\n    writeUInt64BE(data.gasPrice, txReqPayload, off);\n    off += 8;\n    txReqPayload.writeUInt32BE(data.gasLimit, off);\n    off += 4;\n    toBytes.copy(txReqPayload, off);\n    off += 20; // Place the value (a BE number) in an offset such that it\n    // can be interpreted as a number\n\n    const valueOff = off + 32 - valueBytes.length;\n    valueBytes.copy(txReqPayload, valueOff);\n    off += 32; // Ensure data field isn't too long\n\n    if (dataBytes && dataBytes.length > ethMaxDataSz) {\n      throw new Error(`Data field too large (must be <=${ethMaxDataSz} bytes)`);\n    } // Write the data size (does *NOT* include the chainId buffer, if that exists)\n\n\n    txReqPayload.writeUInt16BE(dataBytes.length, off);\n    off += 2;\n    if (dataBytes.length + chainIdBufSz > ethMaxDataSz) throw new Error('Payload too large.'); // Copy in the chainId buffer if needed\n\n    if (chainIdBufSz > 0) {\n      txReqPayload.writeUInt8(chainIdBufSz, off);\n      off++;\n      chainIdBuf.copy(txReqPayload, off);\n      off += chainIdBufSz;\n    } // Copy the data itself\n\n\n    dataBytes.copy(txReqPayload, off);\n    off += ethMaxDataSz;\n    return {\n      rawTx,\n      payload: txReqPayload,\n      schema: constants.signingSchema.ETH_TRANSFER,\n      // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath\n    };\n  } catch (err) {\n    return {\n      err: err.message\n    };\n  }\n}; // From ethereumjs-util\n\n\nfunction stripZeros(a) {\n  let first = a[0];\n\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1);\n    first = a[0];\n  }\n\n  return a;\n} // Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\n\n\nexports.buildEthRawTx = function (tx, sig, address, useEIP155 = true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const newSig = addRecoveryParam(rlpEncoded, sig, address, tx.chainId, useEIP155); // Use the signature to generate a new raw transaction payload\n\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(newSig.v); // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}; // Attach a recovery parameter to a signature by brute-forcing ECRecover\n\n\nfunction addRecoveryParam(payload, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(Buffer.from(keccak256(payload), 'hex'));\n    let v = 0; // Fix signature componenet lengths to 32 bytes each\n\n    const r = fixLen(sig.r, 32);\n    sig.r = r;\n    const s = fixLen(sig.s, 32);\n    sig.s = s; // Calculate the recovery param\n\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1); // If the first `v` value is a match, return the sig!\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } // Otherwise, try the other `v` value\n\n\n    v = 1;\n    pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1);\n\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n}\n\nexports.addRecoveryParam = addRecoveryParam; // Convert an RLP-serialized transaction (plus signature) into a transaction hash\n\nexports.hashTransaction = function (serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex'));\n}; // Returns address string given public key buffer\n\n\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length);\n\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length);\n    return buf;\n  }\n\n  return msg.slice(-length);\n} // Convert a 0/1 `v` into a recovery param:\n// * For non-EIP155 transactions, return `27 + v`\n// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`\n\n\nfunction getRecoveryParam(v, useEIP155, chainId) {\n  // If we are not using EIP155, convert v directly to a buffer and return it\n  if (false === useEIP155) return Buffer.from(new BN(v).plus(27).toString(16), 'hex'); // We will use EIP155 in most cases. Convert v to a bignum and operate on it.\n  // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36\n  // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1\n  // so we add 35 to that.\n\n  const chainIdBuf = getChainIdBuf(chainId);\n  const chainIdBN = new BN(chainIdBuf.toString('hex'), 16);\n  return ensureHexBuffer(chainIdBN.times(2).plus(35).plus(v).toString(16));\n}\n\nfunction writeUInt64BE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.copy(preBuf, preBuf.length - nBuf.length);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction isHexStr(str) {\n  return /^[0-9a-fA-F]+$/.test(str);\n} // Determine if the Lattice can display a string we give it. Currently, the Lattice can only\n// display ASCII strings, so we will reject other UTF8 codes.\n// In the future we may add a mechanism to display certain UTF8 codes such as popular emojis.\n\n\nfunction latticeCanDisplayStr(str) {\n  for (let i = 0; i < str.length; i++) if (str.charCodeAt(i) < 0x0020 || str.charCodeAt(i) > 0x007f) return false;\n\n  return true;\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n}; // Get a buffer containing the chainId value.\n// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian\n\nfunction getChainIdBuf(chainId) {\n  let b; // If our chainID is a hex string, we can convert it to a hex\n  // buffer directly\n\n  if (true === isValidChainIdHexNumStr(chainId)) b = ensureHexBuffer(chainId); // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer\n  else b = ensureHexBuffer(new BN(chainId).toString(16)); // Make sure the buffer is an allowed size\n\n  if (b.length > 8) throw new Error('ChainID provided is too large.'); // If this matches a u16, u32, or u64 size, return it now\n\n  if (b.length <= 2 || b.length === 4 || b.length === 8) return b; // For other size buffers, we need to pack into u32 or u64 before returning;\n\n  let buf;\n\n  if (b.length === 3) {\n    buf = Buffer.alloc(4);\n    buf.writeUInt32BE(chainId);\n  } else if (b.length <= 8) {\n    buf = Buffer.alloc(8);\n    b.copy(buf, 8 - b.length);\n  }\n\n  return buf;\n} // Determine if the chain uses EIP155 by default, based on the chainID\n\n\nfunction chainUsesEIP155(chainID) {\n  switch (chainID) {\n    case 3: // ropsten\n\n    case 4:\n      // rinkeby\n      return false;\n\n    case 1: // mainnet\n\n    case 42: // kovan\n\n    case 5: // goerli\n\n    default:\n      // all others should use eip155\n      return true;\n  }\n} // Determine if a valid number was passed in as a hex string\n\n\nfunction isValidChainIdHexNumStr(s) {\n  return new BN(s, 16).isNaN() === false;\n} // If this is a nubmer that fits in one byte, we don't need to add it\n// to the `data` buffer of the main transaction. \n// Note the one edge case: we still need to use the `data` field for chainID=255.\n\n\nfunction useChainIdBuffer(id) {\n  const buf = getChainIdBuf(id);\n  if (buf.length === 1) return buf.readUInt8(0) === 255;\n  return true;\n}\n\nexports.chainIds = chainIds; // Ensure a param is represented by a buffer\n// TODO: Remove circular dependency in util.js so that we can put this function there\n\nfunction ensureHexBuffer(x) {\n  if (x === null || x === 0) return Buffer.alloc(0);else if (Buffer.isBuffer(x)) x = x.toString('hex');\n  if (typeof x === 'number') x = `${x.toString(16)}`;else if (typeof x === 'string' && x.slice(0, 2) === '0x') x = x.slice(2);\n  if (x.length % 2 > 0) x = `0${x}`;\n  return Buffer.from(x, 'hex');\n}\n\nexports.ensureHexBuffer = ensureHexBuffer;","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/gridplus-sdk/src/ethereum.js"],"names":["BN","require","Buffer","constants","keccak256","rlp","secp256k1","exports","buildEthereumMsgRequest","input","payload","protocol","signerPath","Error","req","schema","signingSchema","ETH_MSG","msg","L","length","ethMaxMsgSz","off","alloc","writeUInt8","ethMsgProtocol","SIGN_PERSONAL","writeUInt32LE","i","displayHex","slice","ensureHexBuffer","isHexStr","latticeCanDisplayStr","from","writeUInt16LE","copy","validateEthereumMsgResponse","res","signer","sig","prefix","toString","addRecoveryParam","concat","buildEthereumTxRequest","data","chainId","eip155","ethMaxDataSz","isValidChainIdHexNumStr","chainIds","useEIP155","chainUsesEIP155","value","rawTx","nonceBytes","nonce","gasPriceBytes","gasPrice","gasLimitBytes","gasLimit","toBytes","to","valueBytes","dataBytes","push","ETH_TX_NON_DATA_SZ","txReqPayload","Number","chainIdBuf","chainIdBufSz","useChainIdBuffer","getChainIdBuf","MAX_CHAIN_ID_BYTES","HANDLE_LARGER_CHAIN_ID","writeUInt32BE","writeUInt64BE","valueOff","writeUInt16BE","ETH_TRANSFER","err","message","stripZeros","a","first","buildEthRawTx","tx","address","rlpEncoded","encode","newSig","newRawTx","v","r","s","hash","Uint8Array","fixLen","rs","pubkey","ecdsaRecover","pubToAddrStr","getRecoveryParam","hashTransaction","serializedTx","pub","buf","plus","chainIdBN","times","n","preBuf","nStr","nBuf","str","test","charCodeAt","mainnet","roptsten","rinkeby","kovan","goerli","b","chainID","isNaN","id","readUInt8","x","isBuffer"],"mappings":"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","sourcesContent":["// Utils for Ethereum transactions. This is effecitvely a shim of ethereumjs-util, which\n// does not have browser (or, by proxy, React-Native) support.\nconst BN = require('bignumber.js');\nconst Buffer = require('buffer/').Buffer\nconst constants = require('./constants');\nconst keccak256 = require('js-sha3').keccak256;\nconst rlp = require('rlp-browser');\nconst secp256k1 = require('secp256k1');\n\nexports.buildEthereumMsgRequest = function(input) {\n  if (!input.payload || !input.protocol || !input.signerPath)\n    throw new Error('You must provide `payload`, `signerPath`, and `protocol` arguments in the messsage request');\n  const req = {\n    schema: constants.signingSchema.ETH_MSG,\n    payload: null,\n    input, // Save the input for later\n    msg: null, // Save the buffered message for later\n  }\n  if (input.protocol === 'signPersonal') {\n    const L = ((input.signerPath.length + 1) * 4) + input.ethMaxMsgSz + 4;\n    let off = 0;\n    req.payload = Buffer.alloc(L);\n    req.payload.writeUInt8(constants.ethMsgProtocol.SIGN_PERSONAL, 0); off += 1;\n    req.payload.writeUInt32LE(input.signerPath.length, off); off += 4;\n    for (let i = 0; i < input.signerPath.length; i++) {\n      req.payload.writeUInt32LE(input.signerPath[i], off); off += 4;\n    }\n    // Write the payload buffer. The payload can come in either as a buffer or as a string\n    let payload = input.payload;\n    // Determine if this is a hex string\n    let displayHex = false;\n    if (typeof input.payload === 'string') {\n      if (input.payload.slice(0, 2) === '0x') {\n        payload = ensureHexBuffer(input.payload)\n        displayHex = true === isHexStr(input.payload.slice(2));\n      } else {\n        if (false === latticeCanDisplayStr(input.payload))\n          throw new Error('Currently, the Lattice can only display ASCII strings.');\n        payload = Buffer.from(input.payload)\n      }\n    } else if (typeof input.displayHex === 'boolean') {\n      // If this is a buffer and the user has specified whether or not this\n      // is a hex buffer with the optional argument, write that\n      displayHex = input.displayHex\n    }\n    // Write the payload and metadata into our buffer\n    req.msg = payload;\n    req.payload.writeUInt8(displayHex, off); off += 1;\n    req.payload.writeUInt16LE(payload.length, off); off += 2;\n    // Make sure we didn't run past the max size\n    if (payload.length > input.ethMaxMsgSz)\n      throw new Error(`Your message is ${payload.length} bytes, but can only be a maximum of ${input.ethMaxMsgSz}`);\n    payload.copy(req.payload, off);\n    return req;\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n}\n\nexports.validateEthereumMsgResponse = function(res, req) {\n  const { signer, sig } = res;\n  const { input, msg } = req;\n  if (input.protocol === 'signPersonal') {\n    const prefix = Buffer.from(\n      `\\u0019Ethereum Signed Message:\\n${msg.length.toString()}`,\n      'utf-8',\n    );\n    return addRecoveryParam(Buffer.concat([prefix, msg]), sig, signer)\n  } else {\n    throw new Error('Unsupported protocol');\n  }\n}\n\nexports.buildEthereumTxRequest = function(data) {\n  try {\n    let { chainId=1 } = data;\n    const { signerPath, eip155=null, ethMaxDataSz } = data;\n    // Sanity checks:\n    // There are a handful of named chains we allow the user to reference (`chainIds`)\n    // Custom chainIDs should be either numerical or hex strings\n    if (typeof chainId !== 'number' && isValidChainIdHexNumStr(chainId) === false) \n      chainId = chainIds[chainId];\n    // If this was not a custom chainID and we cannot find the name of it, exit\n    if (!chainId) \n      throw new Error('Unsupported chain ID or name');\n    // Sanity check on signePath\n    if (!signerPath || signerPath.length !== 5) \n      throw new Error('Please provider full signer path (`signerPath`)')\n\n    // Determine if we should use EIP155 given the chainID.\n    // If we are explicitly told to use eip155, we will use it. Otherwise,\n    // we will look up if the specified chainId is associated with a chain\n    // that does not use EIP155 by default. Note that most do use EIP155.\n    let useEIP155 = chainUsesEIP155(chainId);\n    if (eip155 !== null && typeof eip155 === 'boolean')\n      useEIP155 = eip155;\n\n    // Hack for metamask, which sends value=null for 0 ETH transactions\n    if (!data.value)\n      data.value = 0;\n      \n    //--------------\n    // 1. BUILD THE RAW TX FOR FUTURE RLP ENCODING\n    //--------------\n\n    // Ensure all fields are 0x-prefixed hex strings\n    const rawTx = [];\n    // Build the transaction buffer array\n    const nonceBytes = ensureHexBuffer(data.nonce);\n    const gasPriceBytes = ensureHexBuffer(data.gasPrice);\n    const gasLimitBytes = ensureHexBuffer(data.gasLimit);\n    const toBytes = ensureHexBuffer(data.to);\n    const valueBytes = ensureHexBuffer(data.value);\n    const dataBytes = ensureHexBuffer(data.data);\n\n    rawTx.push(nonceBytes);\n    rawTx.push(gasPriceBytes);\n    rawTx.push(gasLimitBytes);\n    rawTx.push(toBytes);\n    rawTx.push(valueBytes);\n    rawTx.push(dataBytes);\n    // Add empty v,r,s values\n    if (useEIP155 === true) {\n      rawTx.push(ensureHexBuffer(chainId)); // v\n      rawTx.push(ensureHexBuffer(null));    // r\n      rawTx.push(ensureHexBuffer(null));    // s\n    }\n\n    //--------------\n    // 2. BUILD THE LATTICE REQUEST PAYLOAD\n    //--------------\n    const ETH_TX_NON_DATA_SZ = 122; // Accounts for metadata and non-data params\n    const txReqPayload = Buffer.alloc(ethMaxDataSz + ETH_TX_NON_DATA_SZ);\n    let off = 0;\n    // 1. EIP155 switch and chainID\n    //------------------\n    txReqPayload.writeUInt8(Number(useEIP155), off); off++;\n    // NOTE: Originally we designed for a 1-byte chainID, but modern rollup chains use much larger\n    // chainID values. To account for these, we will put the chainID into the `data` buffer if it\n    // is >=255. Values up to UINT64_MAX will be allowed.\n    let chainIdBuf; \n    let chainIdBufSz = 0;\n    if (useChainIdBuffer(chainId) === true) {\n      chainIdBuf = getChainIdBuf(chainId);\n      chainIdBufSz = chainIdBuf.length;\n      if (chainIdBufSz > constants.MAX_CHAIN_ID_BYTES)\n        throw new Error('ChainID provided is too large.');\n      // Signal to Lattice firmware that it needs to read the chainId from the tx.data buffer\n      txReqPayload.writeUInt8(constants.HANDLE_LARGER_CHAIN_ID, off); off++;\n    } else {\n      // For chainIDs <255, write it to the chainId u8 slot in the main tx buffer\n      chainIdBuf = ensureHexBuffer(chainId);\n      if (chainIdBuf.length !== 1)\n        throw new Error('Error parsing chainID');\n      chainIdBuf.copy(txReqPayload, off); off += chainIdBuf.length;\n    }\n\n    // 2. BIP44 Path\n    //------------------\n    // First write the number of indices in this path (will probably always be 5, but\n    // we want to keep this extensible)\n    txReqPayload.writeUInt32LE(signerPath.length, off); off += 4;\n    for (let i = 0; i < signerPath.length; i++) {\n      txReqPayload.writeUInt32LE(signerPath[i], off); off += 4;\n    }\n\n    // 3. ETH TX request data\n    //------------------\n    txReqPayload.writeUInt32BE(data.nonce, off); off += 4;\n    writeUInt64BE(data.gasPrice, txReqPayload, off); off += 8;\n    txReqPayload.writeUInt32BE(data.gasLimit, off); off += 4;\n    toBytes.copy(txReqPayload, off); off += 20;\n    // Place the value (a BE number) in an offset such that it\n    // can be interpreted as a number\n    const valueOff = off + 32 - valueBytes.length;\n    valueBytes.copy(txReqPayload, valueOff); off += 32;\n    // Ensure data field isn't too long\n    if (dataBytes && dataBytes.length > ethMaxDataSz) {\n      throw new Error(`Data field too large (must be <=${ethMaxDataSz} bytes)`);\n    }\n    // Write the data size (does *NOT* include the chainId buffer, if that exists)\n    txReqPayload.writeUInt16BE(dataBytes.length, off); off += 2;\n    if (dataBytes.length + chainIdBufSz > ethMaxDataSz)\n      throw new Error('Payload too large.');\n    // Copy in the chainId buffer if needed\n    if (chainIdBufSz > 0) {\n      txReqPayload.writeUInt8(chainIdBufSz, off); off++;\n      chainIdBuf.copy(txReqPayload, off); off += chainIdBufSz;\n    }\n\n    // Copy the data itself\n    dataBytes.copy(txReqPayload, off); off += ethMaxDataSz;\n    return { \n      rawTx,\n      payload: txReqPayload,\n      schema: constants.signingSchema.ETH_TRANSFER,  // We will use eth transfer for all ETH txs for v1 \n      chainId,\n      useEIP155,\n      signerPath,\n    };\n  } catch (err) {\n    return { err: err.message };\n  }\n}\n\n// From ethereumjs-util\nfunction stripZeros(a) {\n  let first = a[0]\n  while (a.length > 0 && first.toString() === '0') {\n    a = a.slice(1)\n    first = a[0]\n  }\n  return a\n}\n\n// Given a 64-byte signature [r,s] we need to figure out the v value\n// and attah the full signature to the end of the transaction payload\nexports.buildEthRawTx = function(tx, sig, address, useEIP155=true) {\n  // RLP-encode the data we sent to the lattice\n  const rlpEncoded = rlp.encode(tx.rawTx);\n  const newSig = addRecoveryParam(rlpEncoded, sig, address, tx.chainId, useEIP155);\n  // Use the signature to generate a new raw transaction payload\n  const newRawTx = tx.rawTx.slice(0, 6);\n  newRawTx.push(newSig.v);\n  // Per `ethereumjs-tx`, RLP encoding should include signature components w/ stripped zeros\n  // See: https://github.com/ethereumjs/ethereumjs-tx/blob/master/src/transaction.ts#L187\n  newRawTx.push(stripZeros(newSig.r));\n  newRawTx.push(stripZeros(newSig.s));\n  return rlp.encode(newRawTx).toString('hex');\n}\n\n// Attach a recovery parameter to a signature by brute-forcing ECRecover\nfunction addRecoveryParam(payload, sig, address, chainId, useEIP155) {\n  try {\n    // Rebuild the keccak256 hash here so we can `ecrecover`\n    const hash = new Uint8Array(Buffer.from(keccak256(payload), 'hex'));\n    let v = 0;\n    // Fix signature componenet lengths to 32 bytes each\n    const r = fixLen(sig.r, 32); sig.r = r;\n    const s = fixLen(sig.s, 32); sig.s = s;\n    // Calculate the recovery param\n    const rs = new Uint8Array(Buffer.concat([r, s]));\n    let pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)\n    // If the first `v` value is a match, return the sig!\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v  = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    }\n    // Otherwise, try the other `v` value\n    v = 1;\n    pubkey = secp256k1.ecdsaRecover(rs, v, hash, false).slice(1)\n    if (pubToAddrStr(pubkey) === address.toString('hex')) {\n      sig.v  = getRecoveryParam(v, useEIP155, chainId);\n      return sig;\n    } else {\n      // If neither is a match, we should return an error\n      throw new Error('Invalid Ethereum signature returned.');\n    }\n  } catch (err) {\n    throw new Error(err);\n  }\n}\nexports.addRecoveryParam = addRecoveryParam;\n\n// Convert an RLP-serialized transaction (plus signature) into a transaction hash\nexports.hashTransaction = function(serializedTx) {\n  return keccak256(Buffer.from(serializedTx, 'hex')); \n}\n\n// Returns address string given public key buffer\nfunction pubToAddrStr(pub) {\n  return keccak256(pub).slice(-40);\n}\n\nfunction fixLen(msg, length) {\n  const buf = Buffer.alloc(length)\n  if (msg.length < length) {\n    msg.copy(buf, length - msg.length)\n    return buf\n  }\n  return msg.slice(-length)\n}\n\n// Convert a 0/1 `v` into a recovery param:\n// * For non-EIP155 transactions, return `27 + v`\n// * For EIP155 transactions, return `(CHAIN_ID*2) + 35 + v`\nfunction getRecoveryParam(v, useEIP155, chainId) {\n  // If we are not using EIP155, convert v directly to a buffer and return it\n  if (false === useEIP155)\n    return Buffer.from(new BN(v).plus(27).toString(16), 'hex');\n  // We will use EIP155 in most cases. Convert v to a bignum and operate on it.\n  // Note that the protocol calls for v = (CHAIN_ID*2) + 35/36, where 35 or 36\n  // is decided on based on the ecrecover result. `v` is passed in as either 0 or 1\n  // so we add 35 to that.\n  const chainIdBuf = getChainIdBuf(chainId);\n  const chainIdBN = new BN(chainIdBuf.toString('hex'), 16);\n  return ensureHexBuffer(chainIdBN.times(2).plus(35).plus(v).toString(16));\n}\n\nfunction writeUInt64BE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.copy(preBuf, preBuf.length - nBuf.length);\n  preBuf.copy(buf, off);\n  return preBuf;\n}\n\nfunction isHexStr(str) {\n  return (/^[0-9a-fA-F]+$/).test(str)\n}\n\n// Determine if the Lattice can display a string we give it. Currently, the Lattice can only\n// display ASCII strings, so we will reject other UTF8 codes.\n// In the future we may add a mechanism to display certain UTF8 codes such as popular emojis.\nfunction latticeCanDisplayStr(str) {\n  for (let i = 0; i < str.length; i++)\n    if (str.charCodeAt(i) < 0x0020 || str.charCodeAt(i) > 0x007f)\n      return false;\n  return true;\n}\n\nconst chainIds = {\n  mainnet: 1,\n  roptsten: 3,\n  rinkeby: 4,\n  kovan: 42,\n  goerli: 5\n}\n\n// Get a buffer containing the chainId value.\n// Returns a 1, 2, 4, or 8 byte buffer with the chainId encoded in big endian\nfunction getChainIdBuf(chainId) {\n  let b;\n  // If our chainID is a hex string, we can convert it to a hex\n  // buffer directly\n  if (true === isValidChainIdHexNumStr(chainId))\n    b = ensureHexBuffer(chainId);\n  // If our chainID is a base-10 number, parse with bignumber.js and convert to hex buffer\n  else\n    b = ensureHexBuffer(new BN(chainId).toString(16));\n  // Make sure the buffer is an allowed size\n  if (b.length > 8)\n    throw new Error('ChainID provided is too large.');\n  // If this matches a u16, u32, or u64 size, return it now\n  if (b.length <= 2 || b.length === 4 || b.length === 8)\n    return b;\n  // For other size buffers, we need to pack into u32 or u64 before returning;\n  let buf;\n  if (b.length === 3) {\n    buf = Buffer.alloc(4);\n    buf.writeUInt32BE(chainId);\n  } else if (b.length <= 8) {\n    buf = Buffer.alloc(8);\n    b.copy(buf, 8 - b.length)\n  }\n  return buf;\n}\n\n// Determine if the chain uses EIP155 by default, based on the chainID\nfunction chainUsesEIP155(chainID) {\n  switch (chainID) {\n    case 3: // ropsten\n    case 4: // rinkeby\n      return false;\n    case 1: // mainnet\n    case 42: // kovan\n    case 5: // goerli\n    default: // all others should use eip155\n      return true;\n  }\n}\n\n// Determine if a valid number was passed in as a hex string\nfunction isValidChainIdHexNumStr(s) {\n  return new BN(s, 16).isNaN() === false;\n}\n\n// If this is a nubmer that fits in one byte, we don't need to add it\n// to the `data` buffer of the main transaction. \n// Note the one edge case: we still need to use the `data` field for chainID=255.\nfunction useChainIdBuffer(id) {\n  const buf = getChainIdBuf(id);\n  if (buf.length === 1)\n    return buf.readUInt8(0) === 255;\n  return true;\n}\n\nexports.chainIds = chainIds;\n\n// Ensure a param is represented by a buffer\n// TODO: Remove circular dependency in util.js so that we can put this function there\nfunction ensureHexBuffer(x) {\n  if (x === null || x === 0) return Buffer.alloc(0);\n  else if (Buffer.isBuffer(x)) x = x.toString('hex');\n  if (typeof x === 'number') x = `${x.toString(16)}`;\n  else if (typeof x === 'string' && x.slice(0, 2) === '0x') x = x.slice(2);\n  if (x.length % 2 > 0) x = `0${x}`;\n  return Buffer.from(x, 'hex');\n}\nexports.ensureHexBuffer = ensureHexBuffer;"]},"metadata":{},"sourceType":"script"}