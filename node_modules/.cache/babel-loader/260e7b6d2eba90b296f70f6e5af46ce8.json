{"ast":null,"code":"const bitwise = require('bitwise');\n\nconst superagent = require('superagent');\n\nconst bitcoin = require('./bitcoin');\n\nconst ethereum = require('./ethereum');\n\nconst {\n  buildAddAbiPayload,\n  abiParsers,\n  MAX_ABI_DEFS\n} = require('./ethereumAbi');\n\nconst {\n  isValidAssetPath,\n  isValidCoinType,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  ensureHexBuffer,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER\n} = require('./util');\n\nconst {\n  getFwVersionConst,\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL\n} = require('./constants');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({\n    baseUrl,\n    crypto,\n    name,\n    privKey,\n    timeout,\n    retryCount\n  } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown'; // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey); //.encode('hex');\n    // Stateful params\n\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3; // Information about the current wallet. Should be null unless we know a wallet is present\n\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: false\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,\n        // 32 byte id\n        name: null,\n        // 20 char (max) string\n        capabilities: null,\n        // 4 byte flag\n        external: true\n      }\n    };\n  } //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n\n\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) return cb('No device ID has been stored. Please connect with your device ID first.');\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res); // Check for an active wallet. This will get bypassed if we are not paired.\n\n      if (this.isPaired) {\n        this._getActiveWallet(err => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n\n    nameBuf.write(this.name); // Make sure we add a null termination byte to the pairing secret\n\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]); // Build the request\n\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err); // Recover the ephemeral key\n\n      const errStr = this._handlePair(res);\n\n      if (errStr) return cb(errStr); // Try to get the active wallet once pairing is successful\n\n      this._getActiveWallet(err => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    });\n  }\n\n  test(data, cb) {\n    if (!data.payload) return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n\n      if (decrypted.err !== null) return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    });\n  }\n\n  getAddresses(opts, cb) {\n    const SKIP_CACHE_FLAG = 1;\n    const MAX_ADDR = 10;\n    const {\n      startPath,\n      n,\n      skipCache = true\n    } = opts;\n\n    if (startPath === undefined || n === undefined || startPath.length !== 5) {\n      return cb('Please provide `startPath` and `n` options');\n    } else if (n > MAX_ADDR) {\n      return cb(`You may only request ${MAX_ADDR} addresses at once.`);\n    }\n\n    if (skipCache === false && false === isValidAssetPath(startPath) || skipCache === true && false === isValidCoinType(startPath)) return cb('Parent path is not supported');\n    const payload = Buffer.alloc(1 + 32 + startPath.length * 4);\n    let off = 0; // WalletUID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += 32; // Build the start path (5x u32 indices)\n\n    for (let i = 0; i < startPath.length; i++) {\n      payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    } // Specify the number of subsequent addresses to request.\n    // We also allow the user to skip the cache and request any address related to the asset\n    // in the wallet.\n\n\n    let val;\n    const fwConstants = getFwVersionConst(this.fwVersion);\n\n    if (true === fwConstants.addrFlagsAllowed) {\n      const flag = skipCache === true ? bitwise.nibble.read(SKIP_CACHE_FLAG) : bitwise.nibble.read(0);\n      const count = bitwise.nibble.read(n);\n      val = bitwise.byte.write(flag.concat(count));\n    } else {\n      val = n;\n    }\n\n    payload.writeUInt8(val, off);\n    off++;\n\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n\n      const parsedRes = this._handleGetAddresses(res);\n\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    });\n  }\n\n  sign(opts, cb) {\n    const {\n      currency,\n      data\n    } = opts;\n\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    } // All transaction requests must be put into the same sized buffer.\n    // This comes from sizeof(GpTransactionRequest_t), but note we remove\n    // the 2-byte schemaId since it is not returned from our resolver.\n    // Note that different firmware versions may have different data sizes.\n\n\n    const fwConstants = getFwVersionConst(this.fwVersion); // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n\n    data.ethMaxDataSz = fwConstants.ethMaxDataSz;\n    data.ethMaxMsgSz = fwConstants.ethMaxMsgSz;\n    const req = signReqResolver[currency](data);\n    if (req.err !== undefined) return cb(req.err);\n    if (req.payload.length > fwConstants.reqMaxDataSz) return cb('Transaction is too large'); // Build the payload\n\n    const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);\n    let off = 0; // Copy request schema (e.g. ETH or BTC transfer)\n\n    payload.writeUInt16BE(req.schema, off);\n    off += 2; // Copy the wallet UID\n\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off);\n    off += wallet.uid.length; // Build data based on the type of request\n    // Copy the payload of the request\n\n    req.payload.copy(payload, off); // Construct the encrypted request and send it\n\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet(err => {\n          if (err) return cb(err);else return this.sign(opts, cb);\n        });\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    });\n  }\n\n  addAbiDefs(defs, cb, nextCode = null) {\n    const defsToAdd = defs.slice(0, MAX_ABI_DEFS);\n    defs = defs.slice(MAX_ABI_DEFS);\n    let abiPayload;\n\n    try {\n      abiPayload = buildAddAbiPayload(defsToAdd);\n    } catch (err) {\n      return cb(err);\n    }\n\n    const payload = Buffer.alloc(abiPayload.length + 10); // Let the firmware know how many defs are remaining *after this one*.\n    // If this is a positive number, firmware will send us a temporary code\n    // to bypass user authorization if the user has configured easy ABI loading.\n\n    payload.writeUInt16LE(defs.length); // If this is a follow-up request, we don't need to ask for user authorization\n    // if we use the correct temporary u64\n\n    if (nextCode !== null) nextCode.copy(payload, 2);\n    abiPayload.copy(payload, 10);\n\n    const param = this._buildEncRequest(encReqCodes.ADD_ABI_DEFS, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode && responseCode !== responseCodes.RESP_SUCCESS) return cb('Error making request.');else if (err) return cb(err);\n\n      const decrypted = this._handleEncResponse(res, decResLengths.addAbiDefs); // Grab the 8 byte code to fast track our next request, if needed\n\n\n      nextCode = decrypted.data.slice(65, 73); // No defs left? Return success\n\n      if (defs.length === 0) return cb(null); // Add the next set\n\n      this.addAbiDefs(defs, cb, nextCode, defs);\n    });\n  }\n\n  addPermissionV0(opts, cb) {\n    const {\n      currency,\n      timeWindow,\n      limit,\n      decimals,\n      asset\n    } = opts;\n    if (!currency || timeWindow === undefined || limit === undefined || decimals === undefined || timeWindow === null || limit === null || decimals === null) return cb('currency, timeWindow, decimals, and limit are all required options.');else if (timeWindow === 0 || limit === 0) return cb('Time window and spending limit must be positive.'); // Build the name of the permission\n\n    let name = currency;\n    if (asset) name += `_${asset}`; // Start building the payload\n\n    const payload = Buffer.alloc(293); // Copy the name\n\n    if (Buffer.from(name).length > 255) return cb('Asset name too long.');\n    Buffer.from(name).copy(payload, 0); // Convert the limit to a 32 byte hex buffer and copy it in\n\n    const limitBuf = ensureHexBuffer(limit);\n    if (limitBuf.length > 32) return cb('Limit too large.');\n    limitBuf.copy(payload, 256 + (32 - limitBuf.length)); // Copy the time window (seconds)\n\n    payload.writeUInt32BE(timeWindow, 288);\n    payload.writeUInt8(decimals, 292); // Encrypt the request and send it to the Lattice.\n\n    const param = this._buildEncRequest(encReqCodes.ADD_PERMISSION_V0, payload);\n\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet(err => {\n          if (err) return cb(err);else return this.addPermissionV0(opts, cb);\n        });\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const d = this._handleEncResponse(res, decResLengths.finalizePair);\n\n        if (d.err) return cb(d.err);\n        return cb(null);\n      }\n    });\n  } //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n\n\n  _getActiveWallet(cb, forceRefresh = false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n\n          return cb(err);\n        }\n\n        return cb(this._handleGetWallets(res));\n      });\n    }\n  } // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n\n\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  } // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n\n\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null; // EphemId is the first 4 bytes of the hash of the shared secret\n\n    const secret = this._getSharedSecret();\n\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16); // Build the payload and checksum\n\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4); // Lattice validates checksums in little endian\n\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length); // Encrypt this payload\n\n    const secret = this._getSharedSecret();\n\n    const newEncPayload = aes256_encrypt(payloadBuf, secret); // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4); // First 4 bytes are the ephemeral id (in little endian)\n\n    newPayload.writeUInt32LE(ephemId, 0); // Next N bytes\n\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  } // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n\n\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8); // Build the header\n\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i); // Build the payload\n\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i); // Add the checksum\n\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount = this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout).send({\n      data\n    }).then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`);else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`);\n      const parsed = parseLattice1Response(res.body.message); // If the device is busy, retry if we can\n\n      if ((parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY || parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT) && retryCount > 0) {\n        return setTimeout(() => {\n          this._request(data, cb, retryCount - 1);\n        }, 3000);\n      } // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n\n\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) this._resetActiveWallets(); // If there was an error in the response, return it\n\n      if (parsed.err) return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode);\n    }).catch(err => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout) return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.');else return cb('Failed to make request to device.');\n    });\n  } // ----- Device response handlers -----\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n\n\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off);\n    off++; // If we are already paired, we get the next ephemeral key\n\n    const pub = res.slice(off, off + 65).toString('hex');\n    off += 65; // Grab the firmware version (will be 0-length for older fw versions)\n    // It is of format |fix|minor|major|reserved|\n\n    this.fwVersion = res.slice(off, off + 4); // Set the public key\n\n    this.ephemeralPub = getP256KeyPairFromPub(pub); // return the state of our pairing\n\n    return pairingStatus === messageConstants.PAIRED;\n  } // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n\n\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret); // len does not include a 65-byte pubkey that prefies each encResponse\n\n    len += 65; // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len + 4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return {\n      err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})`\n    }; // First 65 bytes is the next ephemeral pubkey\n\n    const pub = res.slice(0, 65).toString('hex');\n\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return {\n        err: null,\n        data: res\n      };\n    } catch (e) {\n      return {\n        err: `Error handling getAddresses response: ${e.toString()}`\n      };\n    }\n  } // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n\n\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n\n    if (d.err) return d.err; // Remove the pairing salt - we're paired!\n\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  } // GetAddresses will return an array of address strings\n\n\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n\n    if (decrypted.err !== null) return decrypted;\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n\n    const addrs = [];\n\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off + ADDR_STR_LEN);\n      off += ADDR_STR_LEN; // Return the UTF-8 representation\n\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n\n      if (len > 0) addrs.push(addrBytes.slice(0, len).toString());\n    }\n\n    return {\n      data: addrs,\n      err: null\n    };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID; // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n\n    const walletDescriptorLen = 71; // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n\n    let off = 65; // Internal first\n\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.internal.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true; // Offset the first item\n\n    off += walletDescriptorLen; // External\n\n    walletUID = res.slice(off, off + 32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off + 32);\n    this.activeWallets.external.name = res.slice(off + 36, off + walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID)) hasActiveWallet = true;\n    if (hasActiveWallet === true) return null;else return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req = null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n\n    if (decrypted.err !== null) return {\n      err: decrypted.err\n    };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n\n    const res = decrypted.data; // Get the change data if we are making a BTC transaction\n\n    let changeRecipient;\n\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN);\n      off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    } // Start building return data\n\n\n    const returnData = {\n      err: null,\n      data: null\n    };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n\n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33; // Size of compressed public key\n\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0; // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break; // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd)); // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n\n        const pubStart = n * compressedPubLength + PUBKEYS_OFFSET;\n        const pubEnd = (n + 1) * compressedPubLength + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd)); // Update offset to hit the next signature slot\n\n        off += DERLength;\n        n += 1;\n      } // Build the transaction data to be serialized\n\n\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        isSegwitSpend: req.origData.isSegwit,\n        network: req.origData.network,\n        crypto: this.crypto\n      }; // First output comes from request dta\n\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient\n      });\n\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient\n        });\n      } // Add the inputs\n\n\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i]\n        });\n      } // Finally, serialize the transaction\n\n\n      const serializedTx = bitcoin.serializeTx(preSerializedData); // Generate the transaction hash so the user can look this transaction up later\n\n      let preImageTxHash = serializedTx;\n\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }\n\n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex'); // Add extra data for debugging/lookup purposes\n\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs\n      };\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const ethAddr = res.slice(off, off + 20); // Determine the `v` param and add it to the sig before returning\n\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex')\n        },\n        signer: ethAddr\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));\n      off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({\n        signer,\n        sig\n      }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex')\n        },\n        signer\n      };\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  } // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n\n\n  pubKeyBytes(LE = false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  } // TODO: Find a better way to export this.\n\n\n  parseAbi(source, data, skipErrors = false) {\n    switch (source) {\n      case 'etherscan':\n        return abiParsers[source](data, skipErrors);\n\n      default:\n        return {\n          err: `No ${source} parser available.`\n        };\n    }\n  }\n\n}\n\nmodule.exports = Client;","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/gridplus-sdk/src/client.js"],"names":["bitwise","require","superagent","bitcoin","ethereum","buildAddAbiPayload","abiParsers","MAX_ABI_DEFS","isValidAssetPath","isValidCoinType","signReqResolver","aes256_decrypt","aes256_encrypt","parseDER","checksum","ensureHexBuffer","getP256KeyPair","getP256KeyPairFromPub","parseLattice1Response","toPaddedDER","getFwVersionConst","ADDR_STR_LEN","ENC_MSG_LEN","decResLengths","deviceCodes","encReqCodes","responseCodes","REQUEST_TYPE_BYTE","VERSION_BYTE","messageConstants","BASE_URL","Buffer","EMPTY_WALLET_UID","alloc","Client","constructor","baseUrl","crypto","name","privKey","timeout","retryCount","length","Error","randomBytes","key","ephemeralPub","sharedSecret","deviceId","isPaired","activeWallets","internal","uid","capabilities","external","connect","cb","param","_buildRequest","CONNECT","pubKeyBytes","_request","err","res","_handleConnect","_getActiveWallet","pair","pairingSecret","pubKey","nameBuf","write","preImage","concat","from","hash","createHash","update","digest","sig","sign","derSig","payload","_buildEncRequest","FINALIZE_PAIRING","errStr","_handlePair","hasActiveWallet","test","data","TEST_DATA_SZ","writeUInt32BE","testID","writeUInt16BE","copy","TEST","decrypted","_handleEncResponse","slice","getAddresses","opts","SKIP_CACHE_FLAG","MAX_ADDR","startPath","n","skipCache","undefined","off","wallet","getActiveWallet","i","val","fwConstants","fwVersion","addrFlagsAllowed","flag","nibble","read","count","byte","writeUInt8","GET_ADDRESSES","parsedRes","_handleGetAddresses","currency","ethMaxDataSz","ethMaxMsgSz","req","reqMaxDataSz","schema","SIGN_TRANSACTION","responseCode","RESP_ERR_WALLET_NOT_PRESENT","_handleSign","addAbiDefs","defs","nextCode","defsToAdd","abiPayload","writeUInt16LE","ADD_ABI_DEFS","RESP_SUCCESS","addPermissionV0","timeWindow","limit","decimals","asset","limitBuf","ADD_PERMISSION_V0","d","finalizePair","forceRefresh","GET_WALLETS","_resetActiveWallets","_handleGetWallets","_getSharedSecret","derive","getPublic","toArray","_getEphemId","secret","enc_request_code","ephemId","parseInt","toString","payloadPreCs","cs","payloadBuf","writeUInt32LE","newEncPayload","newPayload","ENCRYPTED_REQUEST","request_code","L","isBuffer","preReq","id","url","post","send","then","body","status","message","parsed","RESP_ERR_DEV_BUSY","RESP_ERR_GCE_TIMEOUT","setTimeout","catch","isTimeout","code","errno","pairingStatus","readUInt8","pub","PAIRED","encRes","len","encData","toCheck","csCheck","e","pairingSalt","addrData","addrs","addrBytes","indexOf","push","getWallets","walletUID","walletDescriptorLen","readUInt32BE","equals","currencyType","PUBKEY_PREFIX_LEN","PKH_PREFIX_LEN","changeRecipient","changeVersion","addressVersion","changeData","changePubkeyhash","getBitcoinAddress","returnData","DERLength","SIGS_OFFSET","PUBKEYS_OFFSET","compressedPubLength","pubkeys","sigs","sigStart","sigEnd","pubStart","pubEnd","preSerializedData","inputs","outputs","isSegwitSpend","origData","isSegwit","network","value","recipient","prevOuts","txHash","index","pubkey","serializedTx","serializeTx","preImageTxHash","reverse","tx","ethAddr","rawTx","buildEthRawTx","useEIP155","hashTransaction","v","r","s","signer","validatedSig","validateEthereumMsgResponse","LE","k","p","encode","pb","x","y","parseAbi","source","skipErrors","module","exports"],"mappings":"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","sourcesContent":["const bitwise = require('bitwise');\nconst superagent = require('superagent');\nconst bitcoin = require('./bitcoin');\nconst ethereum = require('./ethereum');\nconst { buildAddAbiPayload, abiParsers, MAX_ABI_DEFS } = require('./ethereumAbi');\nconst {\n  isValidAssetPath,\n  isValidCoinType,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  ensureHexBuffer,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  parseLattice1Response,\n  toPaddedDER,\n} = require('./util');\nconst {\n  getFwVersionConst,\n  ADDR_STR_LEN,\n  ENC_MSG_LEN,\n  decResLengths,\n  deviceCodes,\n  encReqCodes,\n  responseCodes,\n  REQUEST_TYPE_BYTE,\n  VERSION_BYTE,\n  messageConstants,\n  BASE_URL,\n} = require('./constants');\nconst Buffer = require('buffer/').Buffer;\nconst EMPTY_WALLET_UID = Buffer.alloc(32);\n\nclass Client {\n  constructor({ baseUrl, crypto, name, privKey, timeout, retryCount } = {}) {\n    // Definitions\n    // if (!baseUrl) throw new Error('baseUrl is required');\n    if (name && name.length > 24) throw new Error('name must be less than 24 characters');\n    if (!crypto) throw new Error('crypto provider is required');\n    this.baseUrl = baseUrl || BASE_URL;\n    this.crypto = crypto;\n    this.name = name || 'Unknown';\n    \n    // Derive an ECDSA keypair using the p256 curve. The public key will\n    // be used as an identifier\n    this.privKey = privKey || this.crypto.randomBytes(32);\n    this.key = getP256KeyPair(this.privKey);//.encode('hex');\n\n    // Stateful params\n    this.ephemeralPub = null;\n    this.sharedSecret = null;\n    this.timeout = timeout || 60000;\n    this.deviceId = null;\n    this.isPaired = false;\n    this.retryCount = retryCount || 3;\n\n    // Information about the current wallet. Should be null unless we know a wallet is present\n    this.activeWallets = {\n      internal: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: false,\n      },\n      external: {\n        uid: EMPTY_WALLET_UID,           // 32 byte id\n        name: null,                      // 20 char (max) string\n        capabilities: null,              // 4 byte flag\n        external: true,\n      }\n    }\n  }\n  \n  //=======================================================================\n  // LATTICE FUNCTIONS\n  //=======================================================================\n\n  // `Connect` will attempt to contact a device based on its deviceId.\n  // The response should include an ephemeral public key, which is used to\n  // pair with the device in a later request\n  connect(deviceId, cb) {\n    // User may \"re-connect\" if a device ID has previously been stored\n    if (typeof deviceId === 'function') {\n      if (!this.deviceId) \n        return cb('No device ID has been stored. Please connect with your device ID first.')\n      cb = deviceId;\n    } else {\n      // If the user passes in a device ID, connect to that device and save\n      // the new ID for future use.\n      this.deviceId = deviceId;\n    }\n    const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      this.isPaired = this._handleConnect(res);\n      // Check for an active wallet. This will get bypassed if we are not paired.\n      if (this.isPaired) {\n        this._getActiveWallet((err) => {\n          return cb(err, this.isPaired);\n        }, true);\n      } else {\n        return cb(null);\n      }\n      \n    });\n  }\n\n  pair(pairingSecret, cb) {\n    // Build the secret hash from the salt\n    const pubKey = this.pubKeyBytes();\n    const nameBuf = Buffer.alloc(25);\n    if (this.name.length > 24) {\n      return cb('Name is too many characters. Please change it to <25 characters.');\n    }\n    nameBuf.write(this.name);\n    // Make sure we add a null termination byte to the pairing secret\n    const preImage = Buffer.concat([pubKey, nameBuf, Buffer.from(pairingSecret)]);\n    const hash = this.crypto.createHash('sha256').update(preImage).digest();\n    const sig = this.key.sign(hash); // returns an array, not a buffer\n    const derSig = toPaddedDER(sig);\n    const payload = Buffer.concat([nameBuf, derSig]);\n\n    // Build the request\n    const param = this._buildEncRequest(encReqCodes.FINALIZE_PAIRING, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      // Recover the ephemeral key\n      const errStr = this._handlePair(res);\n      if (errStr) return cb(errStr);\n      // Try to get the active wallet once pairing is successful\n      this._getActiveWallet((err) => {\n        if (err) return cb(err);\n        return cb(null, this.hasActiveWallet());\n      }, true);\n    })  \n  }\n\n  test(data, cb) {\n    if (!data.payload)\n      return cb('First argument must contain `testID` and `payload` fields.');\n    const TEST_DATA_SZ = 500;\n    const payload = Buffer.alloc(TEST_DATA_SZ + 6);\n    payload.writeUInt32BE(data.testID, 0);\n    payload.writeUInt16BE(data.payload.length, 4);\n    data.payload.copy(payload, 6);\n    const param = this._buildEncRequest(encReqCodes.TEST, payload);\n    this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const decrypted = this._handleEncResponse(res, decResLengths.test);\n      if (decrypted.err !== null ) \n        return cb(decrypted.err);\n      return cb(null, decrypted.data.slice(65)); // remove ephem pub\n    })\n  }\n\n  getAddresses(opts, cb) {\n    const SKIP_CACHE_FLAG = 1;\n    const MAX_ADDR = 10;\n    const { startPath, n, skipCache=true } = opts;\n    if (startPath === undefined || n === undefined || startPath.length !== 5) {\n      return cb('Please provide `startPath` and `n` options');\n    } else if (n > MAX_ADDR) {\n      return cb(`You may only request ${MAX_ADDR} addresses at once.`);\n    }\n\n    if ((skipCache === false && false === isValidAssetPath(startPath)) ||\n        (skipCache === true && false === isValidCoinType(startPath)) )\n      return cb('Parent path is not supported');\n\n    const payload = Buffer.alloc(1 + 32 + startPath.length * 4);\n    let off = 0;\n\n    // WalletUID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += 32;\n    // Build the start path (5x u32 indices)\n    for (let i = 0; i < startPath.length; i++) {\n      payload.writeUInt32BE(startPath[i], off);\n      off += 4;\n    }\n    // Specify the number of subsequent addresses to request.\n    // We also allow the user to skip the cache and request any address related to the asset\n    // in the wallet.\n    let val;\n    const fwConstants = getFwVersionConst(this.fwVersion);\n    if (true === fwConstants.addrFlagsAllowed) {\n      const flag = skipCache === true ? bitwise.nibble.read(SKIP_CACHE_FLAG) : bitwise.nibble.read(0);\n      const count = bitwise.nibble.read(n);\n      val = bitwise.byte.write(flag.concat(count));\n    } else {\n      val = n;\n    }\n    payload.writeUInt8(val, off); off++;\n    const param = this._buildEncRequest(encReqCodes.GET_ADDRESSES, payload);\n    return this._request(param, (err, res) => {\n      if (err) return cb(err);\n      const parsedRes = this._handleGetAddresses(res);\n      if (parsedRes.err) return cb(parsedRes.err);\n      return cb(null, parsedRes.data);\n    })\n  }\n\n  sign(opts, cb) {\n    const { currency, data } = opts;\n    if (currency === undefined || data === undefined) {\n      return cb('Please provide `currency` and `data` options');\n    } else if (signReqResolver[currency] === undefined) {\n      return cb('Unsupported currency');\n    }\n\n    // All transaction requests must be put into the same sized buffer.\n    // This comes from sizeof(GpTransactionRequest_t), but note we remove\n    // the 2-byte schemaId since it is not returned from our resolver.\n    // Note that different firmware versions may have different data sizes.\n    const fwConstants = getFwVersionConst(this.fwVersion);\n\n    // Build the signing request payload to send to the device. If we catch\n    // bad params, return an error instead\n    data.ethMaxDataSz = fwConstants.ethMaxDataSz;\n    data.ethMaxMsgSz = fwConstants.ethMaxMsgSz;\n    const req = signReqResolver[currency](data);\n    if (req.err !== undefined) return cb(req.err);\n\n    if (req.payload.length > fwConstants.reqMaxDataSz)\n      return cb('Transaction is too large');\n\n    // Build the payload\n    const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);\n    let off = 0;\n    // Copy request schema (e.g. ETH or BTC transfer)\n    payload.writeUInt16BE(req.schema, off); off += 2;\n\n    // Copy the wallet UID\n    const wallet = this.getActiveWallet();\n    if (wallet === null) return cb('No active wallet.');\n    wallet.uid.copy(payload, off); off += wallet.uid.length;\n    // Build data based on the type of request\n    // Copy the payload of the request\n    req.payload.copy(payload, off);\n    // Construct the encrypted request and send it\n    const param = this._buildEncRequest(encReqCodes.SIGN_TRANSACTION, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet((err) => {\n          if (err) return cb(err)\n          else     return this.sign(opts, cb);\n        })\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const parsedRes = this._handleSign(res, currency, req);\n        return cb(parsedRes.err, parsedRes.data);\n      }\n    })\n  }\n\n  addAbiDefs(defs, cb, nextCode=null) {\n    const defsToAdd = defs.slice(0, MAX_ABI_DEFS);\n    defs = defs.slice(MAX_ABI_DEFS);\n    let abiPayload;\n    try {\n      abiPayload = buildAddAbiPayload(defsToAdd);\n    } catch (err) {\n      return cb(err);\n    }\n    const payload = Buffer.alloc(abiPayload.length + 10);\n    // Let the firmware know how many defs are remaining *after this one*.\n    // If this is a positive number, firmware will send us a temporary code\n    // to bypass user authorization if the user has configured easy ABI loading.\n    payload.writeUInt16LE(defs.length);\n    // If this is a follow-up request, we don't need to ask for user authorization\n    // if we use the correct temporary u64\n    if (nextCode !== null)\n      nextCode.copy(payload, 2);\n    abiPayload.copy(payload, 10);\n    const param = this._buildEncRequest(encReqCodes.ADD_ABI_DEFS, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode && responseCode !== responseCodes.RESP_SUCCESS)\n        return cb('Error making request.');\n      else if (err)\n        return cb(err);\n      const decrypted = this._handleEncResponse(res, decResLengths.addAbiDefs);\n      // Grab the 8 byte code to fast track our next request, if needed\n      nextCode = decrypted.data.slice(65, 73); \n      // No defs left? Return success\n      if (defs.length === 0)\n        return cb(null);\n      // Add the next set\n      this.addAbiDefs(defs, cb, nextCode, defs);\n    })\n  }\n  \n  addPermissionV0(opts, cb) {\n    const { currency, timeWindow, limit, decimals, asset } = opts;\n    if (!currency || timeWindow === undefined || limit === undefined || decimals === undefined ||\n        timeWindow === null || limit === null || decimals === null)\n      return cb('currency, timeWindow, decimals, and limit are all required options.');\n    else if (timeWindow === 0 || limit === 0)\n      return cb('Time window and spending limit must be positive.');\n    // Build the name of the permission\n    let name = currency;\n    if (asset)\n      name += `_${asset}`;\n    // Start building the payload\n    const payload = Buffer.alloc(293);\n    // Copy the name\n    if (Buffer.from(name).length > 255)\n      return cb('Asset name too long.');\n    Buffer.from(name).copy(payload, 0);\n    // Convert the limit to a 32 byte hex buffer and copy it in\n    const limitBuf = ensureHexBuffer(limit)\n    if (limitBuf.length > 32)\n      return cb('Limit too large.');\n    limitBuf.copy(payload, 256 + (32 - limitBuf.length));\n    // Copy the time window (seconds)\n    payload.writeUInt32BE(timeWindow, 288);\n    payload.writeUInt8(decimals, 292);\n    // Encrypt the request and send it to the Lattice.\n    const param = this._buildEncRequest(encReqCodes.ADD_PERMISSION_V0, payload);\n    return this._request(param, (err, res, responseCode) => {\n      if (responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) {\n        // If we catch a case where the wallet has changed, try getting the new active wallet\n        // and recursively make the original request.\n        this._getActiveWallet((err) => {\n          if (err) return cb(err)\n          else     return this.addPermissionV0(opts, cb);\n        })\n      } else if (err) {\n        // If there was another error caught, return it\n        if (err) return cb(err);\n      } else {\n        // Correct wallet and no errors -- handle the response\n        const d = this._handleEncResponse(res, decResLengths.finalizePair);\n        if (d.err)\n          return cb(d.err);\n        return cb(null);\n      }\n    })\n  }\n\n  //=======================================================================\n  // INTERNAL FUNCTIONS\n  // These handle the logic around building requests and consuming\n  // responses. They take into account the Lattice's serialization scheme\n  // among other protocols.\n  //=======================================================================\n\n  // Get the active wallet in the device. If we already have one recorded,\n  // we don't need to do anything\n  // returns cb(err) -- err is a string\n  _getActiveWallet(cb, forceRefresh=false) {\n    if (forceRefresh !== true && (this.hasActiveWallet() === true || this.isPaired !== true)) {\n      // If the active wallet already exists, or if we are not paired, skip the request\n      return cb(null);\n    } else {\n      // No active wallet? Get it from the device\n      const payload = Buffer.alloc(0);\n      const param = this._buildEncRequest(encReqCodes.GET_WALLETS, payload);\n      return this._request(param, (err, res) => {\n        if (err) {\n          this._resetActiveWallets();\n          return cb(err);\n        }\n        return cb(this._handleGetWallets(res));\n      })\n    }\n  }\n\n  // Get the shared secret, derived via ECDH from the local private key\n  // and the ephemeral public key\n  // @returns Buffer\n  _getSharedSecret() {\n    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which\n    // can lead to problems initializing AES if we don't force a 32 byte BE buffer.\n    return Buffer.from(this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32));\n  }\n\n  // Get the ephemeral id, which is the first 4 bytes of the shared secret\n  // generated from the local private key and the ephemeral public key from\n  // the device.\n  // @returns Buffer\n  _getEphemId() {\n    if (this.ephemeralPub === null) return null;\n    // EphemId is the first 4 bytes of the hash of the shared secret\n    const secret = this._getSharedSecret();\n    const hash = this.crypto.createHash('sha256').update(secret).digest();\n    return hash.slice(0, 4);\n  }\n\n  _buildEncRequest(enc_request_code, payload) {\n    // Get the ephemeral id - all encrypted requests require there to be an\n    // epehemeral public key in order to send\n    const ephemId = parseInt(this._getEphemId().toString('hex'), 16)\n    \n    // Build the payload and checksum\n    const payloadPreCs = Buffer.concat([Buffer.from([enc_request_code]), payload]);\n    const cs = checksum(payloadPreCs);\n    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4);\n\n    // Lattice validates checksums in little endian\n    payloadPreCs.copy(payloadBuf, 0);\n    payloadBuf.writeUInt32LE(cs, payloadPreCs.length);\n    // Encrypt this payload\n    const secret = this._getSharedSecret();\n    const newEncPayload = aes256_encrypt(payloadBuf, secret);\n\n    // Write to the overall payload. We must use the same length\n    // for every encrypted request and must include a 32-bit ephemId\n    // along with the encrypted data\n    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4);\n    // First 4 bytes are the ephemeral id (in little endian)\n    newPayload.writeUInt32LE(ephemId, 0);\n    // Next N bytes\n    newEncPayload.copy(newPayload, 4);\n    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);\n  \n  }\n\n  // Build a request to send to the device.\n  // @param [request_code] {uint8}  - 8-bit unsigned integer representing the message request code\n  // @param [id] {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)\n  // @param [payload] {buffer} - serialized payload\n  // @returns {buffer}\n  _buildRequest(request_code, payload) {\n    // Length of payload;\n    // we add 1 to the payload length to account for the request_code byte\n    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;\n    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {\n      L = 1 + payload.length;\n    }\n    let i = 0;\n    const preReq = Buffer.alloc(L + 8);\n    // Build the header\n    i = preReq.writeUInt8(VERSION_BYTE, i);\n    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);\n    const id = this.crypto.randomBytes(4);\n    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);\n    i = preReq.writeUInt16BE(L, i);\n    // Build the payload\n    i = preReq.writeUInt8(request_code, i);\n    if (L > 1) i = payload.copy(preReq, i);\n    // Add the checksum\n    const cs = checksum(preReq);\n    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum\n    i = preReq.copy(req);\n    req.writeUInt32BE(cs, i);\n    return req;\n  }\n\n  _request(data, cb, retryCount=this.retryCount) {\n    if (!this.deviceId) return cb('Serial is not set. Please set it and try again.');\n    const url = `${this.baseUrl}/${this.deviceId}`;\n    superagent.post(url).timeout(this.timeout)\n    .send({data})\n    .then(res => {\n      if (!res || !res.body) return cb(`Invalid response: ${res}`)\n      else if (res.body.status !== 200) return cb(`Error code ${res.body.status}: ${res.body.message}`)\n      const parsed = parseLattice1Response(res.body.message);\n      // If the device is busy, retry if we can\n      if (( parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY ||\n            parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT ) \n            && (retryCount > 0)) {\n        return setTimeout(() => { this._request(data, cb, retryCount-1) }, 3000);\n      }\n      // If we caugh a `ErrWalletNotPresent` make sure we aren't caching an old ative walletUID\n      if (parsed.responseCode === responseCodes.RESP_ERR_WALLET_NOT_PRESENT) \n        this._resetActiveWallets();\n      // If there was an error in the response, return it\n      if (parsed.err) \n        return cb(parsed.err);\n      return cb(null, parsed.data, parsed.responseCode); \n    })\n    .catch((err) => {\n      const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';\n      if (isTimeout)\n        return cb('Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.')\n      else\n        return cb('Failed to make request to device.');\n    });\n  }\n\n  // ----- Device response handlers -----\n\n  // Connect will call `StartPairingMode` on the device, which gives the\n  // user 60 seconds to finalize the pairing\n  // This will return an ephemeral public key, which is needed for the next\n  // request. If the device is already paired, this ephemPub is simply used\n  // to encrypt the next request. If the device is not paired, it is needed\n  // to pair the device within 60 seconds.\n  // @returns true if we are paired to the device already\n  _handleConnect(res) {\n    let off = 0;\n    const pairingStatus = res.readUInt8(off); off++;\n    // If we are already paired, we get the next ephemeral key\n    const pub = res.slice(off, off + 65).toString('hex'); off += 65;\n    // Grab the firmware version (will be 0-length for older fw versions)\n    // It is of format |fix|minor|major|reserved|\n    this.fwVersion = res.slice(off, off + 4);\n    // Set the public key\n    this.ephemeralPub = getP256KeyPairFromPub(pub);\n    // return the state of our pairing\n    return (pairingStatus === messageConstants.PAIRED);\n  }\n\n  // All encrypted responses must be decrypted with the previous shared secret. Per specification,\n  // decrypted responses will all contain a 65-byte public key as the prefix, which becomes the \n  // new ephemeralPub.\n  _handleEncResponse(encRes, len) {\n    // Decrypt response\n    const secret = this._getSharedSecret();\n    const encData = encRes.slice(0, ENC_MSG_LEN);\n    const res = aes256_decrypt(encData, secret);\n    // len does not include a 65-byte pubkey that prefies each encResponse\n    len += 65;\n    // Validate checksum. It will be the last 4 bytes of the decrypted payload.\n    // The length of the decrypted payload will be fixed for each given message type.\n    const toCheck = res.slice(0, len);\n    const cs = parseInt(`0x${res.slice(len, len+4).toString('hex')}`);\n    const csCheck = checksum(toCheck);\n    if (cs !== csCheck) return { err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})` };\n\n    // First 65 bytes is the next ephemeral pubkey\n    const pub = res.slice(0, 65).toString('hex');\n    try {\n      this.ephemeralPub = getP256KeyPairFromPub(pub);\n      return { err: null, data: res };\n    } catch (e) {\n      return { err: `Error handling getAddresses response: ${e.toString()}` };\n    }\n  }\n\n  // Pair will create a new pairing if the user successfully enters the secret\n  // into the device in time. If successful (status=0), the device will return\n  // a new ephemeral public key, which is used to derive a shared secret\n  // for the next request\n  // @returns error (or null)\n  _handlePair(encRes) {\n    const d = this._handleEncResponse(encRes, decResLengths.finalizePair);\n    if (d.err) return d.err;\n    // Remove the pairing salt - we're paired!\n    this.pairingSalt = null;\n    this.isPaired = true;\n    return null;\n  }\n\n  // GetAddresses will return an array of address strings\n  _handleGetAddresses(encRes) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getAddresses);\n    if (decrypted.err !== null ) return decrypted;\n\n    const addrData = decrypted.data;\n    let off = 65; // Skip 65 byte pubkey prefix\n    // Look for addresses until we reach the end (a 4 byte checksum)\n    const addrs = [];\n    while (off + 4 < decResLengths.getAddresses) {\n      const addrBytes = addrData.slice(off, off+ADDR_STR_LEN); off += ADDR_STR_LEN;\n      // Return the UTF-8 representation\n      const len = addrBytes.indexOf(0); // First 0 is the null terminator\n      if (len > 0)\n        addrs.push(addrBytes.slice(0, len).toString());\n    }\n    return { data: addrs, err: null };\n  }\n\n  _handleGetWallets(encRes) {\n    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);\n    if (decrypted.err !== null) return decrypted;\n    const res = decrypted.data;\n    let walletUID;\n    // Read the external wallet data first. If it is non-null, the external wallet will\n    // be the active wallet of the device and we should save it.\n    // If the external wallet is blank, it means there is no card present and we should \n    // save and use the interal wallet.\n    // If both wallets are empty, it means the device still needs to be set up.\n    const walletDescriptorLen = 71;\n    // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name\n    let off = 65;\n    // Internal first\n    let hasActiveWallet = false;\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.internal.uid = walletUID;\n    this.activeWallets.internal.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.internal.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n\n    // Offset the first item\n    off += walletDescriptorLen;\n    \n    // External\n    walletUID = res.slice(off, off+32);\n    this.activeWallets.external.uid = walletUID;\n    this.activeWallets.external.capabilities = res.readUInt32BE(off+32);\n    this.activeWallets.external.name = res.slice(off+36, off+walletDescriptorLen);\n    if (!walletUID.equals(EMPTY_WALLET_UID))\n      hasActiveWallet = true;\n    if (hasActiveWallet === true)\n      return null;\n    else\n      return 'No active wallet.';\n  }\n\n  _handleSign(encRes, currencyType, req=null) {\n    // Handle the encrypted response\n    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);\n    if (decrypted.err !== null ) return { err: decrypted.err };\n    const PUBKEY_PREFIX_LEN = 65;\n    const PKH_PREFIX_LEN = 20;\n    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix\n    const res = decrypted.data;\n\n    // Get the change data if we are making a BTC transaction\n    let changeRecipient;\n    if (currencyType === 'BTC') {\n      const changeVersion = bitcoin.addressVersion[req.changeData.changeVersion];\n      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN); off += PKH_PREFIX_LEN;\n      changeRecipient = bitcoin.getBitcoinAddress(changePubkeyhash, changeVersion);\n    }\n    // Start building return data\n    const returnData = { err: null, data: null };\n    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long\n    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots\n    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;\n    \n    if (currencyType === 'BTC') {\n      const compressedPubLength = 33;  // Size of compressed public key\n      const pubkeys = [];\n      const sigs = [];\n      let n = 0;\n      // Parse the signature for each output -- they are returned\n      // in the serialized payload in form [pubkey, sig]\n      // There is one signature per output\n      while (off < res.length) {\n        // Exit out if we have seen all the returned sigs and pubkeys\n        if (res[off] !== 0x30) break;\n        // Otherwise grab another set\n        // Note that all DER sigs returned fill the maximum 74 byte buffer, but also\n        // contain a length at off+1, which we use to parse the non-zero data.\n        // First get the signature from its slot\n        const sigStart = off;\n        const sigEnd = off + 2 + res[off + 1];\n        sigs.push(res.slice(sigStart, sigEnd));\n        // Next, shift by the full set of signatures to hit the respective pubkey\n        // NOTE: The data returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]\n        const pubStart = (n * compressedPubLength) + PUBKEYS_OFFSET;\n        const pubEnd = ((n+1) * compressedPubLength) + PUBKEYS_OFFSET;\n        pubkeys.push(res.slice(pubStart, pubEnd));\n        // Update offset to hit the next signature slot\n        off += DERLength;\n        n += 1;\n      }\n      // Build the transaction data to be serialized\n      const preSerializedData = {\n        inputs: [],\n        outputs: [],\n        isSegwitSpend: req.origData.isSegwit,\n        network: req.origData.network,\n        crypto: this.crypto,\n      };\n\n      // First output comes from request dta\n      preSerializedData.outputs.push({\n        value: req.origData.value,\n        recipient: req.origData.recipient,\n      });\n      if (req.changeData.value > 0) {\n        // Second output comes from change data\n        preSerializedData.outputs.push({\n          value: req.changeData.value,\n          recipient: changeRecipient,\n        });\n      }\n      \n      // Add the inputs\n      for (let i = 0; i < sigs.length; i++) {\n        preSerializedData.inputs.push({\n          hash: req.origData.prevOuts[i].txHash,\n          index: req.origData.prevOuts[i].index,\n          sig: sigs[i],\n          pubkey: pubkeys[i],\n        });\n      }\n\n      // Finally, serialize the transaction\n      const serializedTx = bitcoin.serializeTx(preSerializedData);\n      // Generate the transaction hash so the user can look this transaction up later\n      let preImageTxHash = serializedTx;\n      if (preSerializedData.isSegwitSpend === true) {\n        // Segwit transactions need to be re-serialized using legacy serialization\n        // before the transaction hash is calculated. This allows legacy clients\n        // to validate the transactions.\n        preSerializedData.isSegwitSpend = false;\n        preImageTxHash = bitcoin.serializeTx(preSerializedData);\n      }  \n      let txHash = this.crypto.createHash('sha256').update(Buffer.from(preImageTxHash, 'hex')).digest();\n      txHash = this.crypto.createHash('sha256').update(txHash).digest().reverse().toString('hex');\n      \n      // Add extra data for debugging/lookup purposes\n      returnData.data = {\n        tx: serializedTx,\n        txHash,\n        changeRecipient,\n        sigs,\n      }\n    } else if (currencyType === 'ETH') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const ethAddr = res.slice(off, off + 20);\n      // Determine the `v` param and add it to the sig before returning\n      const rawTx = ethereum.buildEthRawTx(req, sig, ethAddr, req.useEIP155);\n      returnData.data = {\n        tx: `0x${rawTx}`,\n        txHash: `0x${ethereum.hashTransaction(rawTx)}`,\n        sig: {\n          v: sig.v,\n          r: sig.r.toString('hex'),\n          s: sig.s.toString('hex'),\n        },\n        signer: ethAddr,\n      };\n    } else if (currencyType === 'ETH_MSG') {\n      const sig = parseDER(res.slice(off, (off + 2 + res[off + 1]))); off += DERLength;\n      const signer = res.slice(off, off + 20);\n      const validatedSig = ethereum.validateEthereumMsgResponse({ signer, sig }, req);\n      returnData.data = {\n        sig: {\n          v: validatedSig.v,\n          r: validatedSig.r.toString('hex'),\n          s: validatedSig.s.toString('hex'),\n        },\n        signer,\n      }\n    }\n\n    return returnData;\n  }\n\n  _resetActiveWallets() {\n    this.activeWallets.internal.uid = EMPTY_WALLET_UID;\n    this.activeWallets.internal.name = null;\n    this.activeWallets.internal.capabilities = null;\n    this.activeWallets.external.uid = EMPTY_WALLET_UID;\n    this.activeWallets.external.name = null;\n    this.activeWallets.external.capabilities = null;\n    return;\n  }\n\n  getActiveWallet() {\n    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {\n      return this.activeWallets.external;\n    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {\n      return this.activeWallets.internal;\n    } else {\n      return null;\n    }\n  }\n\n  hasActiveWallet() {\n    return this.getActiveWallet() !== null;\n  }\n  \n  // Get 64 bytes representing the public key\n  // This is the uncompressed key without the leading 04 byte\n  pubKeyBytes(LE=false) {\n    const k = this.key.getPublic();\n    const p = k.encode('hex');\n    const pb = Buffer.from(p, 'hex');\n    if (LE === true) {\n      // Need to flip X and Y components to little endian\n      const x = pb.slice(1, 33).reverse();\n      const y = pb.slice(33, 65).reverse();\n      return Buffer.concat([pb[0], x, y]);\n    } else {\n      return pb;\n    }\n  }\n\n  // TODO: Find a better way to export this.\n  parseAbi(source, data, skipErrors=false) {\n    switch (source) {\n      case 'etherscan':\n        return abiParsers[source](data, skipErrors);\n      default:\n        return { err: `No ${source} parser available.` };\n\n    }\n  }\n}\n\nmodule.exports = Client;\n"]},"metadata":{},"sourceType":"script"}