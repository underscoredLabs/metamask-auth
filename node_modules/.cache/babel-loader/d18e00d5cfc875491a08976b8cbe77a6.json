{"ast":null,"code":"const Buffer = require('buffer/').Buffer;\n\nconst keccak256 = require('js-sha3').keccak256;\n\nconst {\n  ETH_ABI_LATTICE_FW_TYPE_MAP\n} = require('./constants');\n\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\n\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\n\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS; // Build a request to add ABI data\n\nexports.buildAddAbiPayload = function (defs) {\n  if (!defs || !Array.isArray(defs)) throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS) throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + MAX_ABI_DEFS * (HEADER_SZ + PARAM_SZ * MAX_PARAMS));\n  let off = 0;\n  b.writeUInt8(defs.length, off);\n  off++;\n  defs.forEach(def => {\n    if (!def.sig || !def.name || !def.params) throw new Error('name, sig, and params must be present for every ABI definition.'); // Header data\n\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4) throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off);\n    off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off);\n    off += NAME_MAX_SZ; // Number of parameters\n\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off);\n    off++; // Don't overflow the buffer\n\n    if (numParams > MAX_PARAMS) throw new Error('Currently only ABI defintions with <=10 parameters are supported.'); // Copy the params if needed\n\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach(param => {\n        if (!param.name || !param.latticeTypeIdx || param.isArray === undefined || param.arraySz === undefined) throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off);\n        off += 20;\n      }); // Bump offset to account for blank param slots\n\n      off += 20 * (MAX_PARAMS - numParams); // Next copy the definitions\n\n      def.params.forEach(param => {\n        b.writeUInt8(param.latticeTypeIdx, off);\n        off++;\n        b.writeUInt8(param.isArray === true, off);\n        off++;\n        b.writeUInt32LE(param.arraySz, off);\n        off += 4;\n      }); // Bump offset again\n\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  });\n  return b;\n}; // Get the 4-byte function identifier based on the canonical name\n\n\nexports.getFuncSig = function (f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach(input => {\n    if (input.type.indexOf('tuple') > -1) {\n      const arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);\n      canonicalName += '(';\n      input.components.forEach((c, i) => {\n        canonicalName += `${c.type}${i === input.components.length - 1 ? '' : ','}`;\n      });\n      canonicalName += `)${arrSuffix},`;\n    } else {\n      canonicalName += `${input.type},`;\n    }\n  });\n  if (f.inputs.length > 0) canonicalName = canonicalName.slice(0, canonicalName.length - 1);\n  canonicalName += ')';\n  return keccak256(canonicalName).slice(0, 8);\n}; //--------------------------------------\n// PARSERS\n//--------------------------------------\n\n\nfunction parseEtherscanAbiDefs(_defs, skipErrors = false) {\n  // `_defs` are `result` of the parsed response\n  const defs = [];\n\n  _defs.forEach(d => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view' && d.constant !== true) {\n      try {\n        const sig = exports.getFuncSig(d);\n        const params = parseEtherscanAbiInputs(d.inputs);\n        defs.push({\n          name: d.name,\n          sig,\n          params\n        });\n      } catch (err) {\n        if (skipErrors === true) console.error('Failed to load def:', d.name, err.toString());else throw new Error(err);\n      }\n    }\n  });\n\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs\n}; //--------------------------------------\n// HELPERS\n//--------------------------------------\n// Parse the ABI param data into structs Lattice firmware will recognize.\n\nfunction parseEtherscanAbiInputs(inputs, data = [], isNestedTuple = false) {\n  let tupleParams = [];\n  inputs.forEach(input => {\n    const typeName = input.type;\n    const d = {\n      isArray: false,\n      arraySz: 0,\n      name: input.name\n    };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n\n    if (openBracketIdx > -1 && closeBracketIdx > -1) {\n      if (openBracketIdx >= closeBracketIdx) {\n        ; // not a valid param -- skip it\n      } else if (openBracketIdx + 1 === closeBracketIdx) {\n        d.isArray = true;\n      } else {\n        // Parse the array size if applicable\n        const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx));\n\n        if (isNaN(number)) {\n          return d;\n        }\n\n        d.isArray = true;\n        d.arraySz = number;\n      }\n    }\n\n    let singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n\n    if (singularTypeName === 'tuple') {\n      if (isNestedTuple === true) throw new Error('Nested tuples are not supported');\n      singularTypeName = `tuple${input.components.length}`;\n      tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);\n    }\n\n    d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName);\n    if (!d.latticeTypeIdx) throw new Error(`Unsupported type: ${typeName}`);\n    data.push(d);\n  });\n  const params = data.concat(tupleParams);\n  if (params.length > 18) throw new Error('Function has too many parameters for Lattice firmware (18 max)');\n  return data.concat(tupleParams);\n} // Enum values from inside Lattice firmware\n\n\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/gridplus-sdk/src/ethereumAbi.js"],"names":["Buffer","require","keccak256","ETH_ABI_LATTICE_FW_TYPE_MAP","NAME_MAX_SZ","HEADER_SZ","PARAM_SZ","MAX_PARAMS","MAX_ABI_DEFS","exports","buildAddAbiPayload","defs","Array","isArray","Error","length","b","alloc","off","writeUInt8","forEach","def","sig","name","params","from","copy","slice","numParams","param","latticeTypeIdx","undefined","arraySz","writeUInt32LE","getFuncSig","f","canonicalName","inputs","input","type","indexOf","arrSuffix","components","c","i","parseEtherscanAbiDefs","_defs","skipErrors","d","stateMutability","constant","parseEtherscanAbiInputs","push","err","console","error","toString","abiParsers","etherscan","data","isNestedTuple","tupleParams","typeName","openBracketIdx","closeBracketIdx","number","parseInt","isNaN","singularTypeName","getTypeIdxLatticeFw","concat"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAP,CAAmBD,MAAlC;;AACA,MAAME,SAAS,GAAGD,OAAO,CAAC,SAAD,CAAP,CAAmBC,SAArC;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAkCF,OAAO,CAAC,aAAD,CAA/C;;AACA,MAAMG,WAAW,GAAG,GAApB;AACA,MAAMC,SAAS,GAAG,IAAID,WAAtB,C,CAAmC;;AACnC,MAAME,QAAQ,GAAG,EAAjB,C,CAAqB;;AACrB,MAAMC,UAAU,GAAG,EAAnB;AACA,MAAMC,YAAY,GAAG,CAArB;AACAC,OAAO,CAACD,YAAR,GAAuBA,YAAvB,C,CAEA;;AACAC,OAAO,CAACC,kBAAR,GAA6B,UAASC,IAAT,EAAe;AAC1C,MAAI,CAACA,IAAD,IAAS,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAd,EACE,MAAM,IAAIG,KAAJ,CAAU,sBAAV,CAAN;AACF,MAAIH,IAAI,CAACI,MAAL,GAAcN,OAAO,CAACD,YAA1B,EACE,MAAM,IAAIM,KAAJ,CAAW,oBAAmBN,YAAa,+BAA3C,CAAN;AACF,QAAMQ,CAAC,GAAGhB,MAAM,CAACiB,KAAP,CAAa,IAAKT,YAAY,IAAIH,SAAS,GAAIC,QAAQ,GAAGC,UAA5B,CAA9B,CAAV;AACA,MAAIW,GAAG,GAAG,CAAV;AACAF,EAAAA,CAAC,CAACG,UAAF,CAAaR,IAAI,CAACI,MAAlB,EAA0BG,GAA1B;AAAgCA,EAAAA,GAAG;AACnCP,EAAAA,IAAI,CAACS,OAAL,CAAcC,GAAD,IAAS;AACpB,QAAI,CAACA,GAAG,CAACC,GAAL,IAAY,CAACD,GAAG,CAACE,IAAjB,IAAyB,CAACF,GAAG,CAACG,MAAlC,EACE,MAAM,IAAIV,KAAJ,CAAU,iEAAV,CAAN,CAFkB,CAGpB;;AACA,UAAMQ,GAAG,GAAGtB,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACC,GAAhB,EAAqB,KAArB,CAAZ;AACA,QAAIA,GAAG,CAACP,MAAJ,KAAe,CAAnB,EACE,MAAM,IAAID,KAAJ,CAAU,gDAAV,CAAN;AACFQ,IAAAA,GAAG,CAACI,IAAJ,CAASV,CAAT,EAAYE,GAAZ;AAAkBA,IAAAA,GAAG,IAAII,GAAG,CAACP,MAAX;AAClB,UAAMQ,IAAI,GAAGvB,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACE,IAAhB,CAAb;AACA,QAAIA,IAAI,CAACR,MAAL,GAAcX,WAAW,GAAG,CAAhC,EAAmC;AACjC,YAAM,IAAIU,KAAJ,CAAW,oCAAmCV,WAAY,4BAA1D,CAAN;AACFJ,IAAAA,MAAM,CAACyB,IAAP,CAAYJ,GAAG,CAACE,IAAhB,EAAsBI,KAAtB,CAA4B,CAA5B,EAA+BvB,WAA/B,EAA4CsB,IAA5C,CAAiDV,CAAjD,EAAoDE,GAApD;AAA0DA,IAAAA,GAAG,IAAId,WAAP,CAXtC,CAYpB;;AACA,UAAMwB,SAAS,GAAGhB,KAAK,CAACC,OAAN,CAAcQ,GAAG,CAACG,MAAlB,IAA4BH,GAAG,CAACG,MAAJ,CAAWT,MAAvC,GAAgD,CAAlE;AACAC,IAAAA,CAAC,CAACG,UAAF,CAAaS,SAAb,EAAwBV,GAAxB;AAA8BA,IAAAA,GAAG,GAdb,CAepB;;AACA,QAAIU,SAAS,GAAGrB,UAAhB,EACE,MAAM,IAAIO,KAAJ,CAAU,mEAAV,CAAN,CAjBkB,CAkBpB;;AACA,QAAIc,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACAP,MAAAA,GAAG,CAACG,MAAJ,CAAWJ,OAAX,CAAoBS,KAAD,IAAW;AAC5B,YAAI,CAACA,KAAK,CAACN,IAAP,IAAe,CAACM,KAAK,CAACC,cAAtB,IAAwCD,KAAK,CAAChB,OAAN,KAAkBkB,SAA1D,IAAuEF,KAAK,CAACG,OAAN,KAAkBD,SAA7F,EACE,MAAM,IAAIjB,KAAJ,CAAU,gFAAV,CAAN;AACFd,QAAAA,MAAM,CAACyB,IAAP,CAAYI,KAAK,CAACN,IAAlB,EAAwBI,KAAxB,CAA8B,CAA9B,EAAiC,EAAjC,EAAqCD,IAArC,CAA0CV,CAA1C,EAA6CE,GAA7C;AAAmDA,QAAAA,GAAG,IAAI,EAAP;AACpD,OAJD,EAFiB,CAOjB;;AACAA,MAAAA,GAAG,IAAI,MAAMX,UAAU,GAAGqB,SAAnB,CAAP,CARiB,CASjB;;AACAP,MAAAA,GAAG,CAACG,MAAJ,CAAWJ,OAAX,CAAoBS,KAAD,IAAW;AAC5Bb,QAAAA,CAAC,CAACG,UAAF,CAAaU,KAAK,CAACC,cAAnB,EAAmCZ,GAAnC;AAAyCA,QAAAA,GAAG;AAC5CF,QAAAA,CAAC,CAACG,UAAF,CAAaU,KAAK,CAAChB,OAAN,KAAkB,IAA/B,EAAqCK,GAArC;AAA2CA,QAAAA,GAAG;AAC9CF,QAAAA,CAAC,CAACiB,aAAF,CAAgBJ,KAAK,CAACG,OAAtB,EAA+Bd,GAA/B;AAAqCA,QAAAA,GAAG,IAAI,CAAP;AACtC,OAJD,EAViB,CAejB;;AACAA,MAAAA,GAAG,IAAI,KAAKX,UAAU,GAAGqB,SAAlB,CAAP;AACD,KAjBD,MAiBO;AACL;AACAV,MAAAA,GAAG,IAAIZ,QAAQ,GAAGC,UAAlB;AACD;AACF,GAxCD;AAyCA,SAAOS,CAAP;AACD,CAlDD,C,CAoDA;;;AACAP,OAAO,CAACyB,UAAR,GAAqB,UAASC,CAAT,EAAY;AAC/B;AACA;AACA,MAAIC,aAAa,GAAI,GAAED,CAAC,CAACZ,IAAK,GAA9B;AACAY,EAAAA,CAAC,CAACE,MAAF,CAASjB,OAAT,CAAkBkB,KAAD,IAAW;AAC1B,QAAIA,KAAK,CAACC,IAAN,CAAWC,OAAX,CAAmB,OAAnB,IAA8B,CAAC,CAAnC,EAAsC;AACpC,YAAMC,SAAS,GAAGH,KAAK,CAACC,IAAN,CAAWZ,KAAX,CAAiBW,KAAK,CAACC,IAAN,CAAWC,OAAX,CAAmB,OAAnB,IAA8B,CAA/C,CAAlB;AACAJ,MAAAA,aAAa,IAAI,GAAjB;AACAE,MAAAA,KAAK,CAACI,UAAN,CAAiBtB,OAAjB,CAAyB,CAACuB,CAAD,EAAIC,CAAJ,KAAU;AACjCR,QAAAA,aAAa,IAAK,GAAEO,CAAC,CAACJ,IAAK,GAAEK,CAAC,KAAKN,KAAK,CAACI,UAAN,CAAiB3B,MAAjB,GAA0B,CAAhC,GAAoC,EAApC,GAAyC,GAAI,EAA1E;AACD,OAFD;AAGAqB,MAAAA,aAAa,IAAK,IAAGK,SAAU,GAA/B;AACD,KAPD,MAOO;AACLL,MAAAA,aAAa,IAAK,GAAEE,KAAK,CAACC,IAAK,GAA/B;AACD;AACF,GAXD;AAYA,MAAIJ,CAAC,CAACE,MAAF,CAAStB,MAAT,GAAkB,CAAtB,EACEqB,aAAa,GAAGA,aAAa,CAACT,KAAd,CAAoB,CAApB,EAAuBS,aAAa,CAACrB,MAAd,GAAuB,CAA9C,CAAhB;AACFqB,EAAAA,aAAa,IAAI,GAAjB;AACA,SAAOlC,SAAS,CAACkC,aAAD,CAAT,CAAyBT,KAAzB,CAA+B,CAA/B,EAAkC,CAAlC,CAAP;AACD,CApBD,C,CAsBA;AACA;AACA;;;AACA,SAASkB,qBAAT,CAA+BC,KAA/B,EAAsCC,UAAU,GAAC,KAAjD,EAAwD;AAAE;AACxD,QAAMpC,IAAI,GAAG,EAAb;;AACAmC,EAAAA,KAAK,CAAC1B,OAAN,CAAe4B,CAAD,IAAO;AACnB,QAAIA,CAAC,CAACzB,IAAF,IAAUyB,CAAC,CAACX,MAAZ,IAAsBW,CAAC,CAACT,IAAF,KAAW,UAAjC,IAA+CS,CAAC,CAACC,eAAF,KAAsB,MAArE,IAA+ED,CAAC,CAACE,QAAF,KAAe,IAAlG,EAAwG;AACtG,UAAI;AACF,cAAM5B,GAAG,GAAGb,OAAO,CAACyB,UAAR,CAAmBc,CAAnB,CAAZ;AACA,cAAMxB,MAAM,GAAG2B,uBAAuB,CAACH,CAAC,CAACX,MAAH,CAAtC;AACA1B,QAAAA,IAAI,CAACyC,IAAL,CAAU;AACR7B,UAAAA,IAAI,EAAEyB,CAAC,CAACzB,IADA;AAERD,UAAAA,GAFQ;AAGRE,UAAAA;AAHQ,SAAV;AAKD,OARD,CAQE,OAAO6B,GAAP,EAAY;AACZ,YAAIN,UAAU,KAAK,IAAnB,EACEO,OAAO,CAACC,KAAR,CAAc,qBAAd,EAAqCP,CAAC,CAACzB,IAAvC,EAA6C8B,GAAG,CAACG,QAAJ,EAA7C,EADF,KAGE,MAAM,IAAI1C,KAAJ,CAAUuC,GAAV,CAAN;AACH;AACF;AACF,GAjBD;;AAkBA,SAAO1C,IAAP;AACD;;AAEDF,OAAO,CAACgD,UAAR,GAAqB;AACnBC,EAAAA,SAAS,EAAEb;AADQ,CAArB,C,CAIA;AACA;AACA;AACA;;AACA,SAASM,uBAAT,CAAiCd,MAAjC,EAAyCsB,IAAI,GAAC,EAA9C,EAAkDC,aAAa,GAAC,KAAhE,EAAuE;AACrE,MAAIC,WAAW,GAAG,EAAlB;AACAxB,EAAAA,MAAM,CAACjB,OAAP,CAAgBkB,KAAD,IAAW;AACxB,UAAMwB,QAAQ,GAAGxB,KAAK,CAACC,IAAvB;AACA,UAAMS,CAAC,GAAG;AAAEnC,MAAAA,OAAO,EAAE,KAAX;AAAkBmB,MAAAA,OAAO,EAAE,CAA3B;AAA8BT,MAAAA,IAAI,EAAEe,KAAK,CAACf;AAA1C,KAAV;AACA,UAAMwC,cAAc,GAAGD,QAAQ,CAACtB,OAAT,CAAiB,GAAjB,CAAvB;AACA,UAAMwB,eAAe,GAAGF,QAAQ,CAACtB,OAAT,CAAiB,GAAjB,CAAxB;;AACA,QAAIuB,cAAc,GAAG,CAAC,CAAlB,IAAuBC,eAAe,GAAG,CAAC,CAA9C,EAAiD;AAC/C,UAAID,cAAc,IAAIC,eAAtB,EAAuC;AACrC,SADqC,CACnC;AACH,OAFD,MAEO,IAAKD,cAAc,GAAG,CAAlB,KAAyBC,eAA7B,EAA8C;AACnDhB,QAAAA,CAAC,CAACnC,OAAF,GAAY,IAAZ;AACD,OAFM,MAEA;AACL;AACA,cAAMoD,MAAM,GAAGC,QAAQ,CAACJ,QAAQ,CAACnC,KAAT,CAAeoC,cAAf,EAA+BC,eAA/B,CAAD,CAAvB;;AACA,YAAIG,KAAK,CAACF,MAAD,CAAT,EAAmB;AACjB,iBAAOjB,CAAP;AACD;;AACDA,QAAAA,CAAC,CAACnC,OAAF,GAAY,IAAZ;AACAmC,QAAAA,CAAC,CAAChB,OAAF,GAAYiC,MAAZ;AACD;AACF;;AACD,QAAIG,gBAAgB,GAAGL,cAAc,GAAG,CAAC,CAAlB,GAAsBD,QAAQ,CAACnC,KAAT,CAAe,CAAf,EAAkBoC,cAAlB,CAAtB,GAA0DD,QAAjF;;AACA,QAAIM,gBAAgB,KAAK,OAAzB,EAAkC;AAChC,UAAIR,aAAa,KAAK,IAAtB,EACE,MAAM,IAAI9C,KAAJ,CAAU,iCAAV,CAAN;AACFsD,MAAAA,gBAAgB,GAAI,QAAO9B,KAAK,CAACI,UAAN,CAAiB3B,MAAO,EAAnD;AACA8C,MAAAA,WAAW,GAAGV,uBAAuB,CAACb,KAAK,CAACI,UAAP,EAAmBmB,WAAnB,EAAgC,IAAhC,CAArC;AACD;;AACDb,IAAAA,CAAC,CAAClB,cAAF,GAAmBuC,mBAAmB,CAACD,gBAAD,CAAtC;AACA,QAAI,CAACpB,CAAC,CAAClB,cAAP,EACE,MAAM,IAAIhB,KAAJ,CAAW,qBAAoBgD,QAAS,EAAxC,CAAN;AACFH,IAAAA,IAAI,CAACP,IAAL,CAAUJ,CAAV;AACD,GA/BD;AAgCA,QAAMxB,MAAM,GAAGmC,IAAI,CAACW,MAAL,CAAYT,WAAZ,CAAf;AACA,MAAIrC,MAAM,CAACT,MAAP,GAAgB,EAApB,EACE,MAAM,IAAID,KAAJ,CAAU,gEAAV,CAAN;AACF,SAAO6C,IAAI,CAACW,MAAL,CAAYT,WAAZ,CAAP;AACD,C,CAED;;;AACA,SAASQ,mBAAT,CAA6B9B,IAA7B,EAAmC;AACjC,SAAOpC,2BAA2B,CAACoC,IAAD,CAAlC;AACD","sourcesContent":["const Buffer = require('buffer/').Buffer\nconst keccak256 = require('js-sha3').keccak256;\nconst { ETH_ABI_LATTICE_FW_TYPE_MAP } = require('./constants');\nconst NAME_MAX_SZ = 100;\nconst HEADER_SZ = 5 + NAME_MAX_SZ; // 4 byte sig + name + 1 byte param count\nconst PARAM_SZ = 26; // 20 byte name + 6 byte def\nconst MAX_PARAMS = 18;\nconst MAX_ABI_DEFS = 2;\nexports.MAX_ABI_DEFS = MAX_ABI_DEFS;\n\n// Build a request to add ABI data\nexports.buildAddAbiPayload = function(defs) {\n  if (!defs || !Array.isArray(defs))\n    throw new Error('Missing definitions.');\n  if (defs.length > exports.MAX_ABI_DEFS)\n    throw new Error(`You may only add ${MAX_ABI_DEFS} ABI definitions per request.`);\n  const b = Buffer.alloc(1 + (MAX_ABI_DEFS * (HEADER_SZ + (PARAM_SZ * MAX_PARAMS))));\n  let off = 0;\n  b.writeUInt8(defs.length, off); off++;\n  defs.forEach((def) => {\n    if (!def.sig || !def.name || !def.params)\n      throw new Error('name, sig, and params must be present for every ABI definition.')\n    // Header data\n    const sig = Buffer.from(def.sig, 'hex');\n    if (sig.length !== 4)\n      throw new Error('Function signatures must always be four bytes.');\n    sig.copy(b, off); off += sig.length;\n    const name = Buffer.from(def.name);\n    if (name.length > NAME_MAX_SZ - 1) // The -1 accounts for the null terminator\n      throw new Error(`Only function names shorter than ${NAME_MAX_SZ} characters are supported.`);\n    Buffer.from(def.name).slice(0, NAME_MAX_SZ).copy(b, off); off += NAME_MAX_SZ;\n    // Number of parameters\n    const numParams = Array.isArray(def.params) ? def.params.length : 0;\n    b.writeUInt8(numParams, off); off++;\n    // Don't overflow the buffer\n    if (numParams > MAX_PARAMS)\n      throw new Error('Currently only ABI defintions with <=10 parameters are supported.');\n    // Copy the params if needed\n    if (numParams > 0) {\n      // First copy param names (first 20 bytes)\n      def.params.forEach((param) => {\n        if (!param.name || !param.latticeTypeIdx || param.isArray === undefined || param.arraySz === undefined)\n          throw new Error('name, latticeTypeIdx, isArray, and arraySz must be defined for all ABI params.');\n        Buffer.from(param.name).slice(0, 20).copy(b, off); off += 20;\n      })\n      // Bump offset to account for blank param slots\n      off += 20 * (MAX_PARAMS - numParams);\n      // Next copy the definitions\n      def.params.forEach((param) => {\n        b.writeUInt8(param.latticeTypeIdx, off); off++;\n        b.writeUInt8(param.isArray === true, off); off++;\n        b.writeUInt32LE(param.arraySz, off); off += 4;\n      })\n      // Bump offset again\n      off += 6 * (MAX_PARAMS - numParams);\n    } else {\n      // If there are no params, just bump the offset\n      off += PARAM_SZ * MAX_PARAMS;\n    }\n  })\n  return b;\n}\n\n// Get the 4-byte function identifier based on the canonical name\nexports.getFuncSig = function(f) {\n  // Canonical name is:\n  // funcName(paramType0, ..., paramTypeN)\n  let canonicalName = `${f.name}(`;\n  f.inputs.forEach((input) => {\n    if (input.type.indexOf('tuple') > -1) {\n      const arrSuffix = input.type.slice(input.type.indexOf('tuple') + 5);\n      canonicalName += '('\n      input.components.forEach((c, i) => {\n        canonicalName += `${c.type}${i === input.components.length - 1 ? '' : ','}`;\n      })\n      canonicalName += `)${arrSuffix},`\n    } else {\n      canonicalName += `${input.type},`\n    }\n  })\n  if (f.inputs.length > 0)\n    canonicalName = canonicalName.slice(0, canonicalName.length - 1)\n  canonicalName += ')'\n  return keccak256(canonicalName).slice(0, 8);\n}\n\n//--------------------------------------\n// PARSERS\n//--------------------------------------\nfunction parseEtherscanAbiDefs(_defs, skipErrors=false) { // `_defs` are `result` of the parsed response\n  const defs = [];\n  _defs.forEach((d) => {\n    if (d.name && d.inputs && d.type === 'function' && d.stateMutability !== 'view' && d.constant !== true) {\n      try {\n        const sig = exports.getFuncSig(d);\n        const params = parseEtherscanAbiInputs(d.inputs);\n        defs.push({\n          name: d.name,\n          sig,\n          params,\n        })\n      } catch (err) {\n        if (skipErrors === true)\n          console.error('Failed to load def:', d.name, err.toString())\n        else\n          throw new Error(err)\n      }\n    }\n  })\n  return defs;\n}\n\nexports.abiParsers = {\n  etherscan: parseEtherscanAbiDefs,\n}\n\n//--------------------------------------\n// HELPERS\n//--------------------------------------\n// Parse the ABI param data into structs Lattice firmware will recognize.\nfunction parseEtherscanAbiInputs(inputs, data=[], isNestedTuple=false) {\n  let tupleParams = [];\n  inputs.forEach((input) => {\n    const typeName = input.type;\n    const d = { isArray: false, arraySz: 0, name: input.name, };\n    const openBracketIdx = typeName.indexOf('[');\n    const closeBracketIdx = typeName.indexOf(']');\n    if (openBracketIdx > -1 && closeBracketIdx > -1) {\n      if (openBracketIdx >= closeBracketIdx) {\n        ; // not a valid param -- skip it\n      } else if ((openBracketIdx + 1) === closeBracketIdx) {\n        d.isArray = true;\n      } else {\n        // Parse the array size if applicable\n        const number = parseInt(typeName.slice(openBracketIdx, closeBracketIdx))\n        if (isNaN(number)) {\n          return d;\n        }\n        d.isArray = true;\n        d.arraySz = number;\n      }\n    }\n    let singularTypeName = openBracketIdx > -1 ? typeName.slice(0, openBracketIdx) : typeName;\n    if (singularTypeName === 'tuple') {\n      if (isNestedTuple === true)\n        throw new Error('Nested tuples are not supported')\n      singularTypeName = `tuple${input.components.length}`;\n      tupleParams = parseEtherscanAbiInputs(input.components, tupleParams, true);\n    }\n    d.latticeTypeIdx = getTypeIdxLatticeFw(singularTypeName)\n    if (!d.latticeTypeIdx)\n      throw new Error(`Unsupported type: ${typeName}`)\n    data.push(d)\n  })\n  const params = data.concat(tupleParams)\n  if (params.length > 18)\n    throw new Error('Function has too many parameters for Lattice firmware (18 max)')\n  return data.concat(tupleParams);\n}\n\n// Enum values from inside Lattice firmware\nfunction getTypeIdxLatticeFw(type) {\n  return ETH_ABI_LATTICE_FW_TYPE_MAP[type];\n}\n"]},"metadata":{},"sourceType":"script"}