{"ast":null,"code":"const EventEmitter = require('events');\n\nconst {\n  v4: uuid\n} = require('uuid');\n\nconst dev = process.env.NODE_ENV === 'development';\nlet XHR;\n\nclass HTTPConnection extends EventEmitter {\n  constructor(_XHR, url, options) {\n    super();\n    XHR = _XHR;\n    this.options = options;\n    this.connected = false;\n    this.subscriptions = false;\n    this.status = 'loading';\n    this.url = url;\n    this.pollId = uuid();\n    setTimeout(() => this.create(), 0);\n\n    this._emit = (...args) => !this.closed ? this.emit(...args) : null;\n  }\n\n  create() {\n    if (!XHR) return this._emit('error', new Error('No HTTP transport available'));\n    this.on('error', () => {\n      if (this.connected) this.close();\n    });\n    this.init();\n  }\n\n  init() {\n    this.send({\n      jsonrpc: '2.0',\n      method: 'net_version',\n      params: [],\n      id: 1\n    }, (err, response) => {\n      if (err) return this._emit('error', err);\n      this.connected = true;\n\n      this._emit('connect');\n\n      this.send({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'eth_pollSubscriptions',\n        params: [this.pollId, 'immediate']\n      }, (err, response) => {\n        if (!err) {\n          this.subscriptions = true;\n          this.pollSubscriptions();\n        }\n      });\n    });\n  }\n\n  pollSubscriptions() {\n    this.send({\n      jsonrpc: '2.0',\n      id: 1,\n      method: 'eth_pollSubscriptions',\n      params: [this.pollId]\n    }, (err, result) => {\n      if (err) {\n        this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 10000);\n        return this._emit('error', err);\n      } else {\n        if (!this.closed) this.subscriptionTimeout = this.pollSubscriptions();\n\n        if (result) {\n          result.map(p => {\n            let parse;\n\n            try {\n              parse = JSON.parse(p);\n            } catch (e) {\n              parse = false;\n            }\n\n            return parse;\n          }).filter(n => n).forEach(p => this._emit('payload', p));\n        }\n      }\n    });\n  }\n\n  close() {\n    if (dev) console.log('Closing HTTP connection');\n    this.closed = true;\n\n    this._emit('close');\n\n    clearTimeout(this.subscriptionTimeout);\n    this.removeAllListeners();\n  }\n\n  filterStatus(res) {\n    if (res.status >= 200 && res.status < 300) return res;\n    const error = new Error(res.statusText);\n    error.res = res;\n    throw error.message;\n  }\n\n  error(payload, message, code = -1) {\n    this._emit('payload', {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      error: {\n        message,\n        code\n      }\n    });\n  }\n\n  send(payload, internal) {\n    if (this.closed) return this.error(payload, 'Not connected');\n\n    if (payload.method === 'eth_subscribe') {\n      if (this.subscriptions) {\n        payload.pollId = this.pollId;\n      } else {\n        return this.error(payload, 'Subscriptions are not supported by this HTTP endpoint');\n      }\n    }\n\n    const xhr = new XHR();\n    let responded = false;\n\n    const res = (err, result) => {\n      if (!responded) {\n        xhr.abort();\n        responded = true;\n\n        if (internal) {\n          internal(err, result);\n        } else {\n          const {\n            id,\n            jsonrpc\n          } = payload;\n          const load = err ? {\n            id,\n            jsonrpc,\n            error: {\n              message: err.message,\n              code: err.code\n            }\n          } : {\n            id,\n            jsonrpc,\n            result\n          };\n\n          this._emit('payload', load);\n        }\n      }\n    };\n\n    xhr.open('POST', this.url, true);\n    xhr.setRequestHeader('Content-Type', 'application/json'); // Below not working becasue XHR lib blocks it claiming \"restricted header\"\n    // if (this.options.origin) xhr.setRequestHeader('Origin', this.options.origin)\n\n    xhr.timeout = 60 * 1000;\n    xhr.onerror = res;\n    xhr.ontimeout = res;\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        try {\n          const response = JSON.parse(xhr.responseText);\n          res(response.error, response.result);\n        } catch (e) {\n          res(e);\n        }\n      }\n    };\n\n    xhr.send(JSON.stringify(payload));\n  }\n\n}\n\nmodule.exports = XHR => (url, options) => new HTTPConnection(XHR, url, options);","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/eth-provider/connections/http.js"],"names":["EventEmitter","require","v4","uuid","dev","process","env","NODE_ENV","XHR","HTTPConnection","constructor","_XHR","url","options","connected","subscriptions","status","pollId","setTimeout","create","_emit","args","closed","emit","Error","on","close","init","send","jsonrpc","method","params","id","err","response","pollSubscriptions","result","subscriptionTimeout","map","p","parse","JSON","e","filter","n","forEach","console","log","clearTimeout","removeAllListeners","filterStatus","res","error","statusText","message","payload","code","internal","xhr","responded","abort","load","open","setRequestHeader","timeout","onerror","ontimeout","onreadystatechange","readyState","responseText","stringify","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\nconst { v4: uuid } = require('uuid')\n\nconst dev = process.env.NODE_ENV === 'development'\n\nlet XHR\n\nclass HTTPConnection extends EventEmitter {\n  constructor (_XHR, url, options) {\n    super()\n    XHR = _XHR\n    this.options = options\n    this.connected = false\n    this.subscriptions = false\n    this.status = 'loading'\n    this.url = url\n    this.pollId = uuid()\n    setTimeout(() => this.create(), 0)\n    this._emit = (...args) => !this.closed ? this.emit(...args) : null\n  }\n\n  create () {\n    if (!XHR) return this._emit('error', new Error('No HTTP transport available'))\n    this.on('error', () => { if (this.connected) this.close() })\n    this.init()\n  }\n\n  init () {\n    this.send({ jsonrpc: '2.0', method: 'net_version', params: [], id: 1 }, (err, response) => {\n      if (err) return this._emit('error', err)\n      this.connected = true\n      this._emit('connect')\n      this.send({ jsonrpc: '2.0', id: 1, method: 'eth_pollSubscriptions', params: [this.pollId, 'immediate'] }, (err, response) => {\n        if (!err) {\n          this.subscriptions = true\n          this.pollSubscriptions()\n        }\n      })\n    })\n  }\n\n  pollSubscriptions () {\n    this.send({ jsonrpc: '2.0', id: 1, method: 'eth_pollSubscriptions', params: [this.pollId] }, (err, result) => {\n      if (err) {\n        this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 10000)\n        return this._emit('error', err)\n      } else {\n        if (!this.closed) this.subscriptionTimeout = this.pollSubscriptions()\n        if (result) {\n          result.map(p => {\n            let parse\n            try { parse = JSON.parse(p) } catch (e) { parse = false }\n            return parse\n          }).filter(n => n).forEach(p => this._emit('payload', p))\n        }\n      }\n    })\n  }\n\n  close () {\n    if (dev) console.log('Closing HTTP connection')\n    this.closed = true\n    this._emit('close')\n    clearTimeout(this.subscriptionTimeout)\n    this.removeAllListeners()\n  }\n\n  filterStatus (res) {\n    if (res.status >= 200 && res.status < 300) return res\n    const error = new Error(res.statusText)\n    error.res = res\n    throw error.message\n  }\n\n  error (payload, message, code = -1) {\n    this._emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload, internal) {\n    if (this.closed) return this.error(payload, 'Not connected')\n    if (payload.method === 'eth_subscribe') {\n      if (this.subscriptions) {\n        payload.pollId = this.pollId\n      } else {\n        return this.error(payload, 'Subscriptions are not supported by this HTTP endpoint')\n      }\n    }\n    const xhr = new XHR()\n    let responded = false\n    const res = (err, result) => {\n      if (!responded) {\n        xhr.abort()\n        responded = true\n        if (internal) {\n          internal(err, result)\n        } else {\n          const { id, jsonrpc } = payload\n          const load = err ? { id, jsonrpc, error: { message: err.message, code: err.code } } : { id, jsonrpc, result }\n          this._emit('payload', load)\n        }\n      }\n    }\n    xhr.open('POST', this.url, true)\n    xhr.setRequestHeader('Content-Type', 'application/json')\n    // Below not working becasue XHR lib blocks it claiming \"restricted header\"\n    // if (this.options.origin) xhr.setRequestHeader('Origin', this.options.origin)\n    xhr.timeout = 60 * 1000\n    xhr.onerror = res\n    xhr.ontimeout = res\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        try {\n          const response = JSON.parse(xhr.responseText)\n          res(response.error, response.result)\n        } catch (e) {\n          res(e)\n        }\n      }\n    }\n    xhr.send(JSON.stringify(payload))\n  }\n}\n\nmodule.exports = XHR => (url, options) => new HTTPConnection(XHR, url, options)\n"]},"metadata":{},"sourceType":"script"}