{"ast":null,"code":"// Static utility functions\nconst {\n  buildBitcoinTxRequest\n} = require('./bitcoin');\n\nconst {\n  buildEthereumTxRequest,\n  buildEthereumMsgRequest,\n  ensureHexBuffer\n} = require('./ethereum');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst aes = require('aes-js');\n\nconst crc32 = require('crc-32');\n\nconst elliptic = require('elliptic');\n\nconst {\n  AES_IV,\n  responseCodes,\n  responseMsgs,\n  VERSION_BYTE\n} = require('./constants');\n\nconst EC = elliptic.ec;\nconst ec = new EC('p256'); //--------------------------------------------------\n// LATTICE UTILS\n//--------------------------------------------------\n// Parse a response from the Lattice1\n\nfunction parseLattice1Response(r) {\n  const parsed = {\n    err: null,\n    data: null\n  };\n  const b = Buffer.from(r, 'hex');\n  let off = 0; // Get protocol version\n\n  const protoVer = b.readUInt8(off);\n  off++;\n\n  if (protoVer !== VERSION_BYTE) {\n    parsed.err = 'Incorrect protocol version. Please update your SDK';\n    return parsed;\n  } // Get the type of response\n  // Should always be 0x00\n\n\n  const msgType = b.readUInt8(off);\n  off++;\n\n  if (msgType !== 0x00) {\n    parsed.err = 'Incorrect response from Lattice1';\n    return parsed;\n  } // Get the payload\n\n\n  b.readUInt32BE(off);\n  off += 4; // First 4 bytes is the id, but we don't need that anymore\n\n  const len = b.readUInt16BE(off);\n  off += 2;\n  const payload = b.slice(off, off + len);\n  off += len; // Get response code\n\n  const responseCode = payload.readUInt8(0);\n\n  if (responseCode !== responseCodes.RESP_SUCCESS) {\n    parsed.err = `Error from device: ${responseMsgs[responseCode] ? responseMsgs[responseCode] : 'Unknown Error'}`;\n    parsed.responseCode = responseCode;\n    return parsed;\n  } else {\n    parsed.data = payload.slice(1, payload.length);\n  } // Verify checksum\n\n\n  const cs = b.readUInt32BE(off);\n  const expectedCs = checksum(b.slice(0, b.length - 4));\n\n  if (cs !== expectedCs) {\n    parsed.err = 'Invalid checksum from device response';\n    parsed.data = null;\n    return parsed;\n  }\n\n  return parsed;\n}\n\nfunction checksum(x) {\n  // crc32 returns a signed integer - need to cast it to unsigned\n  // Note that this uses the default 0xedb88320 polynomial\n  return crc32.buf(x) >>> 0; // Need this to be a uint, hence the bit shift\n} // Get a 74-byte padded DER-encoded signature buffer\n// `sig` must be the signature output from elliptic.js\n\n\nfunction toPaddedDER(sig) {\n  // We use 74 as the maximum length of a DER signature. All sigs must\n  // be right-padded with zeros so that this can be a fixed size field\n  const b = Buffer.alloc(74);\n  const ds = Buffer.from(sig.toDER());\n  ds.copy(b);\n  return b;\n} //--------------------------------------------------\n// TRANSACTION UTILS\n//--------------------------------------------------\n\n\nconst signReqResolver = {\n  'BTC': buildBitcoinTxRequest,\n  'ETH': buildEthereumTxRequest,\n  'ETH_MSG': buildEthereumMsgRequest\n}; // Temporary helper to determine if this is a supported BIP44 parent path\n\nfunction isValidAssetPath(path) {\n  const HARDENED_OFFSET = 0x80000000;\n  const allowedPurposes = [HARDENED_OFFSET + 49, HARDENED_OFFSET + 44];\n  const allowedCoins = [HARDENED_OFFSET, HARDENED_OFFSET + 1, HARDENED_OFFSET + 60];\n  const allowedAccounts = [HARDENED_OFFSET];\n  const allowedChange = [0, 1];\n  return allowedPurposes.indexOf(path[0]) >= 0 && allowedCoins.indexOf(path[1]) >= 0 && allowedAccounts.indexOf(path[2]) >= 0 && allowedChange.indexOf(path[3]) >= 0;\n}\n\nfunction isValidCoinType(path) {\n  return [0x80000000, 0x80000000 + 1, 0x80000000 + 60].indexOf(path[1]) >= 0;\n} //--------------------------------------------------\n// CRYPTO UTILS\n//--------------------------------------------------\n\n\nfunction aes256_encrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  const paddedData = data.length % 16 === 0 ? data : aes.padding.pkcs7.pad(data);\n  return Buffer.from(aesCbc.encrypt(paddedData));\n}\n\nfunction aes256_decrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  return Buffer.from(aesCbc.decrypt(data));\n} // Decode a DER signature. Returns signature object {r, s } or null if there is an error\n\n\nfunction parseDER(sigBuf) {\n  if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02) return null;\n  let off = 3;\n  const sig = {\n    r: null,\n    s: null\n  };\n  const rLen = sigBuf[off];\n  off++;\n  sig.r = sigBuf.slice(off, off + rLen);\n  off += rLen;\n  if (sigBuf[off] !== 0x02) return null;\n  off++;\n  const sLen = sigBuf[off];\n  off++;\n  sig.s = sigBuf.slice(off, off + sLen);\n  return sig;\n}\n\nfunction getP256KeyPair(priv) {\n  return ec.keyFromPrivate(priv, 'hex');\n}\n\nfunction getP256KeyPairFromPub(pub) {\n  return ec.keyFromPublic(pub, 'hex');\n}\n\nmodule.exports = {\n  isValidAssetPath,\n  isValidCoinType,\n  ensureHexBuffer,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  parseLattice1Response,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  toPaddedDER\n};","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/gridplus-sdk/src/util.js"],"names":["buildBitcoinTxRequest","require","buildEthereumTxRequest","buildEthereumMsgRequest","ensureHexBuffer","Buffer","aes","crc32","elliptic","AES_IV","responseCodes","responseMsgs","VERSION_BYTE","EC","ec","parseLattice1Response","r","parsed","err","data","b","from","off","protoVer","readUInt8","msgType","readUInt32BE","len","readUInt16BE","payload","slice","responseCode","RESP_SUCCESS","length","cs","expectedCs","checksum","x","buf","toPaddedDER","sig","alloc","ds","toDER","copy","signReqResolver","isValidAssetPath","path","HARDENED_OFFSET","allowedPurposes","allowedCoins","allowedAccounts","allowedChange","indexOf","isValidCoinType","aes256_encrypt","key","iv","aesCbc","ModeOfOperation","cbc","paddedData","padding","pkcs7","pad","encrypt","aes256_decrypt","decrypt","parseDER","sigBuf","s","rLen","sLen","getP256KeyPair","priv","keyFromPrivate","getP256KeyPairFromPub","pub","keyFromPublic","module","exports"],"mappings":"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","sourcesContent":["// Static utility functions\nconst { buildBitcoinTxRequest } = require('./bitcoin');\nconst { buildEthereumTxRequest, buildEthereumMsgRequest, ensureHexBuffer } = require('./ethereum');\nconst Buffer = require('buffer/').Buffer\nconst aes = require('aes-js');\nconst crc32 = require('crc-32');\nconst elliptic = require('elliptic');\nconst { AES_IV, responseCodes, responseMsgs, VERSION_BYTE } = require('./constants');\nconst EC = elliptic.ec;\nconst ec = new EC('p256');\n\n//--------------------------------------------------\n// LATTICE UTILS\n//--------------------------------------------------\n\n// Parse a response from the Lattice1\nfunction parseLattice1Response(r) {\n  const parsed = {\n    err: null,\n    data: null,\n  }\n  const b = Buffer.from(r, 'hex');\n  let off = 0;\n  \n  // Get protocol version\n  const protoVer = b.readUInt8(off); off++;\n  if (protoVer !== VERSION_BYTE) {\n    parsed.err = 'Incorrect protocol version. Please update your SDK';\n    return parsed;\n  }\n\n  // Get the type of response\n  // Should always be 0x00\n  const msgType = b.readUInt8(off); off++;\n  if (msgType !== 0x00) {\n    parsed.err = 'Incorrect response from Lattice1';\n    return parsed;\n  }\n\n  // Get the payload\n  b.readUInt32BE(off); off+=4; // First 4 bytes is the id, but we don't need that anymore\n  const len = b.readUInt16BE(off); off+=2;\n  const payload = b.slice(off, off+len); off+=len;\n\n  // Get response code\n  const responseCode = payload.readUInt8(0);\n  if (responseCode !== responseCodes.RESP_SUCCESS) {\n    parsed.err = `Error from device: ${responseMsgs[responseCode] ? responseMsgs[responseCode] : 'Unknown Error'}`;\n    parsed.responseCode = responseCode;\n    return parsed;\n  } else {\n    parsed.data = payload.slice(1, payload.length);\n  }\n\n  // Verify checksum\n  const cs = b.readUInt32BE(off);\n  const expectedCs = checksum(b.slice(0, b.length - 4));\n  if (cs !== expectedCs) {\n    parsed.err = 'Invalid checksum from device response'\n    parsed.data = null;\n    return parsed;\n  }\n  \n  return parsed;\n}\n\nfunction checksum(x) {\n  // crc32 returns a signed integer - need to cast it to unsigned\n  // Note that this uses the default 0xedb88320 polynomial\n  return crc32.buf(x) >>> 0; // Need this to be a uint, hence the bit shift\n}\n\n// Get a 74-byte padded DER-encoded signature buffer\n// `sig` must be the signature output from elliptic.js\nfunction toPaddedDER(sig) {\n  // We use 74 as the maximum length of a DER signature. All sigs must\n  // be right-padded with zeros so that this can be a fixed size field\n  const b = Buffer.alloc(74);\n  const ds = Buffer.from(sig.toDER());\n  ds.copy(b);\n  return b;\n}\n\n//--------------------------------------------------\n// TRANSACTION UTILS\n//--------------------------------------------------\nconst signReqResolver = {\n  'BTC': buildBitcoinTxRequest,\n  'ETH': buildEthereumTxRequest,\n  'ETH_MSG': buildEthereumMsgRequest,\n}\n\n// Temporary helper to determine if this is a supported BIP44 parent path\nfunction isValidAssetPath(path) {\n  const HARDENED_OFFSET = 0x80000000;\n  const allowedPurposes = [HARDENED_OFFSET+49, HARDENED_OFFSET+44];\n  const allowedCoins = [HARDENED_OFFSET, HARDENED_OFFSET+1, HARDENED_OFFSET+60];\n  const allowedAccounts = [HARDENED_OFFSET];\n  const allowedChange = [0, 1]\n  return (\n    (allowedPurposes.indexOf(path[0]) >= 0) &&\n    (allowedCoins.indexOf(path[1]) >= 0) &&\n    (allowedAccounts.indexOf(path[2]) >= 0) &&\n    (allowedChange.indexOf(path[3]) >= 0)\n  );\n}\n\nfunction isValidCoinType(path) {\n  return [0x80000000, 0x80000000+1, 0x80000000+60].indexOf(path[1]) >= 0\n}\n\n//--------------------------------------------------\n// CRYPTO UTILS\n//--------------------------------------------------\nfunction aes256_encrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  const paddedData = (data.length) % 16 === 0 ? data : aes.padding.pkcs7.pad(data);\n  return Buffer.from(aesCbc.encrypt(paddedData));\n}\n\nfunction aes256_decrypt(data, key) {\n  const iv = Buffer.from(AES_IV);\n  const aesCbc = new aes.ModeOfOperation.cbc(key, iv);\n  return Buffer.from(aesCbc.decrypt(data));\n}\n\n// Decode a DER signature. Returns signature object {r, s } or null if there is an error\nfunction parseDER(sigBuf) {\n  if (sigBuf[0] !== 0x30 || sigBuf[2] !== 0x02) return null;\n  let off = 3;\n  const sig = { r: null, s: null }\n  const rLen = sigBuf[off]; off++;\n  sig.r = sigBuf.slice(off, off + rLen); off += rLen\n  if (sigBuf[off] !== 0x02) return null;\n  off++;\n  const sLen = sigBuf[off]; off++;\n  sig.s = sigBuf.slice(off, off + sLen);\n  return sig;\n}\n\nfunction getP256KeyPair (priv) {\n  return ec.keyFromPrivate(priv, 'hex');\n}\n\nfunction getP256KeyPairFromPub(pub) {\n  return ec.keyFromPublic(pub, 'hex');\n}\n\n\nmodule.exports = {\n  isValidAssetPath,\n  isValidCoinType,\n  ensureHexBuffer,\n  signReqResolver,\n  aes256_decrypt,\n  aes256_encrypt,\n  parseDER,\n  checksum,\n  parseLattice1Response,\n  getP256KeyPair,\n  getP256KeyPairFromPub,\n  toPaddedDER,\n}"]},"metadata":{},"sourceType":"script"}