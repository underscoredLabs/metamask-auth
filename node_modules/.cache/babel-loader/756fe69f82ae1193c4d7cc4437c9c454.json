{"ast":null,"code":"const crypto = require('crypto');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst SDK = require('gridplus-sdk');\n\nconst keyringType = 'Lattice Hardware';\nconst HARDENED_OFFSET = 0x80000000;\nconst PER_PAGE = 5;\nconst CLOSE_CODE = -1000;\n\nclass LatticeKeyring extends EventEmitter {\n  constructor(opts = {}) {\n    super();\n    this.type = keyringType;\n\n    this._resetDefaults();\n\n    this.deserialize(opts);\n  } //-------------------------------------------------------------------\n  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)\n  //-------------------------------------------------------------------\n\n\n  deserialize(opts = {}) {\n    if (opts.creds) this.creds = opts.creds;\n    if (opts.accounts) this.accounts = opts.accounts;\n    if (opts.accountIndices) this.accountIndices = opts.accountIndices;\n    if (opts.walletUID) this.walletUID = opts.walletUID;\n    if (opts.name) this.name = opts.name;\n    if (opts.network) this.network = opts.network;\n    if (opts.page) this.page = opts.page;\n    return Promise.resolve();\n  }\n\n  serialize() {\n    return Promise.resolve({\n      creds: this.creds,\n      accounts: this.accounts,\n      walletUID: this.walletUID,\n      name: this.name,\n      network: this.network,\n      page: this.page\n    });\n  }\n\n  isUnlocked() {\n    return this._hasCreds() && this._hasSession();\n  }\n\n  setHdPath() {\n    console.warn(\"setHdPath not implemented.\");\n    return;\n  } // Initialize a session with the Lattice1 device using the GridPlus SDK\n\n\n  unlock(updateData = true) {\n    return new Promise((resolve, reject) => {\n      this._getCreds().then(creds => {\n        if (creds) {\n          this.creds.deviceID = creds.deviceID;\n          this.creds.password = creds.password;\n          this.creds.endpoint = creds.endpoint || null;\n        }\n\n        return this._initSession();\n      }).then(() => {\n        return this._connect(updateData);\n      }).then(() => {\n        return resolve('Unlocked');\n      }).catch(err => {\n        return reject(new Error(err));\n      });\n    });\n  } // Add addresses to the local store and return the full result\n\n\n  addAccounts(n = 1) {\n    return new Promise((resolve, reject) => {\n      if (n === CLOSE_CODE) {\n        // Special case: use a code to forget the device. \n        // (This function is overloaded due to constraints upstream)\n        this.forgetDevice();\n        return resolve([]);\n      } else if (n <= 0) {\n        // Avoid non-positive numbers.\n        return reject('Number of accounts to add must be a positive number.');\n      } else {\n        // Normal behavior: establish the connection and fetch addresses.\n        this.unlock().then(() => {\n          return this._fetchAddresses(n, this.unlockedAccount);\n        }).then(addrs => {\n          // Add these indices\n          addrs.forEach((addr, i) => {\n            if (this.accounts.indexOf(addr) === -1) {\n              this.accounts.push(addr);\n              this.accountIndices.push(this.unlockedAccount + i);\n            }\n          });\n          return resolve(this.accounts);\n        }).catch(err => {\n          return reject(new Error(err));\n        });\n      }\n    });\n  } // Return the local store of addresses\n\n\n  getAccounts() {\n    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());\n  }\n\n  signTransaction(address, tx) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address).then(addrIdx => {\n        // Build the Lattice request data and make request\n        const txData = {\n          chainId: tx.getChainId() || 1,\n          nonce: Number(`0x${tx.nonce.toString('hex')}`) || 0,\n          gasPrice: Number(`0x${tx.gasPrice.toString('hex')}`),\n          gasLimit: Number(`0x${tx.gasLimit.toString('hex')}`),\n          to: `0x${tx.to.toString('hex')}`,\n          value: Number(`0x${tx.value.toString('hex')}`),\n          data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,\n          signerPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, addrIdx]\n        };\n        return this._signTxData(txData);\n      }).then(signedTx => {\n        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`\n        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s) return reject(Error('No signature returned'));\n        tx.v = signedTx.sig.v;\n        tx.r = Buffer.from(signedTx.sig.r, 'hex');\n        tx.s = Buffer.from(signedTx.sig.s, 'hex');\n        return resolve(tx);\n      }).catch(err => {\n        return reject(new Error(err));\n      });\n    });\n  }\n\n  signPersonalMessage(address, msg) {\n    return this.signMessage(address, {\n      payload: msg,\n      protocol: 'signPersonal'\n    });\n  }\n\n  signMessage(address, msg) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address).then(addrIdx => {\n        const {\n          payload,\n          protocol\n        } = msg;\n        if (!payload || !protocol) return reject('`payload` and `protocol` fields must be included in the request');\n        const req = {\n          currency: 'ETH_MSG',\n          data: {\n            protocol,\n            payload,\n            signerPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, addrIdx]\n          }\n        };\n        if (!this._hasSession()) return reject('No SDK session started. Cannot sign transaction.');\n        this.sdkSession.sign(req, (err, res) => {\n          if (err) return reject(new Error(err));\n          if (!res.sig) return reject('No signature returned');\n          let v = (res.sig.v - 27).toString(16);\n          if (v.length < 2) v = `0${v}`;\n          return resolve(`0x${res.sig.r}${res.sig.s}${v}`);\n        });\n      });\n    });\n  }\n\n  exportAccount(address) {\n    return Promise.reject(Error('exportAccount not supported by this device'));\n  }\n\n  removeAccount(address) {\n    // We only allow one account at a time, so removing any account\n    // should result in a state reset. The user will need to reconnect\n    // to the Lattice\n    this.forgetDevice();\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(0);\n  }\n\n  getNextPage() {\n    return this._getPage(1);\n  }\n\n  getPreviousPage() {\n    return this._getPage(-1);\n  }\n\n  setAccountToUnlock(index) {\n    this.unlockedAccount = parseInt(index, 10);\n  }\n\n  forgetDevice() {\n    this._resetDefaults();\n  } //-------------------------------------------------------------------\n  // Internal methods and interface to SDK\n  //-------------------------------------------------------------------\n  // Find the account index of the requested address.\n  // Note that this is the BIP39 path index, not the index in the address cache.\n\n\n  _unlockAndFindAccount(address) {\n    return new Promise((resolve, reject) => {\n      // NOTE: We are passing `false` here because we do NOT want\n      // state data to be updated as a result of a transaction request.\n      // It is possible the user inserted or removed a SafeCard and\n      // will not be able to sign this transaction. If that is the\n      // case, we just want to return an error message\n      this.unlock(false).then(() => {\n        return this.getAccounts();\n      }).then(addrs => {\n        // Find the signer in our current set of accounts\n        // If we can't find it, return an error\n        let addrIdx = null;\n        addrs.forEach((addr, i) => {\n          if (address.toLowerCase() === addr.toLowerCase()) addrIdx = i;\n        });\n        if (addrIdx === null) return reject('Signer not present');\n        return resolve(this.accountIndices[addrIdx]);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n\n  _resetDefaults() {\n    this.accounts = [];\n    this.accountIndices = [];\n    this.isLocked = true;\n    this.creds = {\n      deviceID: null,\n      password: null,\n      endpoint: null\n    };\n    this.walletUID = null;\n    this.sdkSession = null;\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.network = null;\n  }\n\n  _getCreds() {\n    return new Promise((resolve, reject) => {\n      // We only need to setup if we don't have a deviceID\n      if (this._hasCreds()) return resolve(); // If we are not aware of what Lattice we should be talking to,\n      // we need to open a window that lets the user go through the\n      // pairing or connection process.\n\n      const name = this.name ? this.name : 'Unknown';\n      let base = 'https://wallet.gridplus.io';\n\n      switch (this.network) {\n        case 'rinkeby':\n          base = 'https://gridplus-web-wallet-dev.herokuapp.com';\n          break;\n\n        default:\n          break;\n      }\n\n      let url = `${base}?keyring=${name}`;\n      if (this.network) url += `&network=${this.network}`;\n      const popup = window.open(url);\n      popup.postMessage('GET_LATTICE_CREDS', base); // PostMessage handler\n\n      function receiveMessage(event) {\n        // Ensure origin\n        if (event.origin !== base) return; // Parse response data\n\n        try {\n          const data = JSON.parse(event.data);\n          if (!data.deviceID || !data.password) return reject(Error('Invalid credentials returned from Lattice.'));\n          return resolve(data);\n        } catch (err) {\n          return reject(err);\n        }\n      }\n\n      window.addEventListener(\"message\", receiveMessage, false);\n    });\n  } // [re]connect to the Lattice. This should be done frequently to ensure\n  // the expected wallet UID is still the one active in the Lattice.\n  // This will handle SafeCard insertion/removal events.\n  // updateData - true if you want to overwrite walletUID and accounts in\n  //              the event that we find we are not synced.\n  //              If left false and we notice a new walletUID, we will\n  //              return an error.\n\n\n  _connect(updateData) {\n    return new Promise((resolve, reject) => {\n      this.sdkSession.connect(this.creds.deviceID, err => {\n        if (err) return reject(err); // Save the current wallet UID\n\n        const activeWallet = this.sdkSession.getActiveWallet();\n        if (!activeWallet || !activeWallet.uid) return reject(\"No active wallet\");\n        const newUID = activeWallet.uid.toString('hex'); // If we fetched a walletUID that does not match our current one,\n        // reset accounts and update the known UID\n\n        if (newUID != this.walletUID) {\n          // If we don't want to update data, return an error\n          if (updateData === false) return reject('Wallet has changed! Please reconnect.'); // By default we should clear out accounts and update with\n          // the new walletUID. We should NOT fill in the accounts yet,\n          // as we reserve that functionality to `addAccounts`\n\n          this.accounts = [];\n          this.walletUID = newUID;\n        }\n\n        return resolve();\n      });\n    });\n  }\n\n  _initSession() {\n    return new Promise((resolve, reject) => {\n      if (this._hasSession()) return resolve();\n\n      try {\n        let url = 'https://signing.gridpl.us';\n        if (this.network && this.network !== 'mainnet') url = 'https://signing.staging-gridpl.us';\n        if (this.creds.endpoint) url = this.creds.endpoint;\n        const setupData = {\n          name: this.name,\n          baseUrl: url,\n          crypto,\n          timeout: 120000,\n          privKey: this._genSessionKey(),\n          network: this.network\n        };\n        this.sdkSession = new SDK.Client(setupData);\n        return resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    });\n  }\n\n  _fetchAddresses(n = 1, i = 0) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession()) return reject('No SDK session started. Cannot fetch addresses.'); // If we have already cached the address(es), we don't need to do it again\n\n      if (this.accounts.length > i + n) return resolve(this.accounts.slice(i, n)); // Make the request to get the requested address\n\n      const addrData = {\n        currency: 'ETH',\n        startPath: [HARDENED_OFFSET + 44, HARDENED_OFFSET + 60, HARDENED_OFFSET, 0, i],\n        n,\n        skipCache: true\n      };\n      this.sdkSession.getAddresses(addrData, (err, addrs) => {\n        if (err) return reject(Error(`Error getting addresses: ${err}`)); // Sanity check -- if this returned 0 addresses, handle the error\n\n        if (addrs.length < 1) return reject('No addresses returned'); // Return the addresses we fetched *without* updating state\n\n        return resolve(addrs);\n      });\n    });\n  }\n\n  _signTxData(txData) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession()) return reject('No SDK session started. Cannot sign transaction.');\n      this.sdkSession.sign({\n        currency: 'ETH',\n        data: txData\n      }, (err, res) => {\n        if (err) return reject(err);\n        if (!res.tx) return reject('No transaction payload returned.');\n        return resolve(res);\n      });\n    });\n  }\n\n  _getPage(increment = 0) {\n    return new Promise((resolve, reject) => {\n      this.page += increment;\n      if (this.page < 0) this.page = 0;\n      const start = PER_PAGE * this.page; // Otherwise unlock the device and fetch more addresses\n\n      this.unlock().then(() => {\n        return this._fetchAddresses(PER_PAGE, start);\n      }).then(addrs => {\n        const accounts = [];\n        addrs.forEach((address, i) => {\n          accounts.push({\n            address,\n            balance: null,\n            index: start + i\n          });\n        });\n        return resolve(accounts);\n      }).catch(err => {\n        return reject(err);\n      });\n    });\n  }\n\n  _hasCreds() {\n    return this.creds.deviceID !== null && this.creds.password !== null && this.name;\n  }\n\n  _hasSession() {\n    return this.sdkSession && this.walletUID;\n  }\n\n  _genSessionKey() {\n    if (!this._hasCreds()) throw new Error('No credentials -- cannot create session key!');\n    const buf = Buffer.concat([Buffer.from(this.creds.password), Buffer.from(this.creds.deviceID), Buffer.from(this.name)]);\n    return crypto.createHash('sha256').update(buf).digest();\n  }\n\n}\n\nLatticeKeyring.type = keyringType;\nmodule.exports = LatticeKeyring;","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/eth-lattice-keyring/index.js"],"names":["crypto","require","EventEmitter","SDK","keyringType","HARDENED_OFFSET","PER_PAGE","CLOSE_CODE","LatticeKeyring","constructor","opts","type","_resetDefaults","deserialize","creds","accounts","accountIndices","walletUID","name","network","page","Promise","resolve","serialize","isUnlocked","_hasCreds","_hasSession","setHdPath","console","warn","unlock","updateData","reject","_getCreds","then","deviceID","password","endpoint","_initSession","_connect","catch","err","Error","addAccounts","n","forgetDevice","_fetchAddresses","unlockedAccount","addrs","forEach","addr","i","indexOf","push","getAccounts","slice","signTransaction","address","tx","_unlockAndFindAccount","addrIdx","txData","chainId","getChainId","nonce","Number","toString","gasPrice","gasLimit","to","value","data","length","signerPath","_signTxData","signedTx","sig","v","r","s","Buffer","from","signPersonalMessage","msg","signMessage","payload","protocol","req","currency","sdkSession","sign","res","exportAccount","removeAccount","getFirstPage","_getPage","getNextPage","getPreviousPage","setAccountToUnlock","index","parseInt","toLowerCase","isLocked","base","url","popup","window","open","postMessage","receiveMessage","event","origin","JSON","parse","addEventListener","connect","activeWallet","getActiveWallet","uid","newUID","setupData","baseUrl","timeout","privKey","_genSessionKey","Client","addrData","startPath","skipCache","getAddresses","increment","start","balance","buf","concat","createHash","update","digest","module","exports"],"mappings":"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","sourcesContent":["const crypto = require('crypto');\nconst EventEmitter = require('events').EventEmitter;\nconst SDK = require('gridplus-sdk');\nconst keyringType = 'Lattice Hardware';\nconst HARDENED_OFFSET = 0x80000000;\nconst PER_PAGE = 5;\nconst CLOSE_CODE = -1000;\n\nclass LatticeKeyring extends EventEmitter {\n  constructor (opts={}) {\n    super()\n    this.type = keyringType\n    this._resetDefaults();\n    this.deserialize(opts);\n  }\n\n  //-------------------------------------------------------------------\n  // Keyring API (per `https://github.com/MetaMask/eth-simple-keyring`)\n  //-------------------------------------------------------------------\n  deserialize (opts = {}) {\n    if (opts.creds)\n      this.creds = opts.creds;\n    if (opts.accounts)\n      this.accounts = opts.accounts;\n    if (opts.accountIndices)\n      this.accountIndices = opts.accountIndices\n    if (opts.walletUID)\n      this.walletUID = opts.walletUID;\n    if (opts.name)\n      this.name = opts.name;\n    if (opts.network)\n      this.network = opts.network;\n    if (opts.page)\n      this.page = opts.page;\n    return Promise.resolve()\n  }\n\n  serialize() {\n    return Promise.resolve({\n      creds: this.creds,\n      accounts: this.accounts,\n      walletUID: this.walletUID,\n      name: this.name,\n      network: this.network,\n      page: this.page,\n    })\n  }\n\n  isUnlocked () {\n    return this._hasCreds() && this._hasSession()\n  }\n\n  setHdPath() {\n    console.warn(\"setHdPath not implemented.\")\n    return;\n  }\n\n  // Initialize a session with the Lattice1 device using the GridPlus SDK\n  unlock(updateData=true) {\n    return new Promise((resolve, reject) => {\n      this._getCreds()\n      .then((creds) => {\n        if (creds) {\n          this.creds.deviceID = creds.deviceID;\n          this.creds.password = creds.password;\n          this.creds.endpoint = creds.endpoint || null;\n        }\n        return this._initSession();\n      })\n      .then(() => {\n        return this._connect(updateData);\n      })\n      .then(() => {\n        return resolve('Unlocked');\n      })\n      .catch((err) => {\n        return reject(new Error(err));\n      })\n    })\n  }\n\n  // Add addresses to the local store and return the full result\n  addAccounts(n=1) {\n    return new Promise((resolve, reject) => {\n      if (n === CLOSE_CODE) {\n        // Special case: use a code to forget the device. \n        // (This function is overloaded due to constraints upstream)\n        this.forgetDevice();\n        return resolve([]);\n      } else if (n <= 0) {\n        // Avoid non-positive numbers.\n        return reject('Number of accounts to add must be a positive number.');\n      } else {\n        // Normal behavior: establish the connection and fetch addresses.\n        this.unlock()\n        .then(() => {\n          return this._fetchAddresses(n, this.unlockedAccount)\n        })\n        .then((addrs) => {\n          // Add these indices\n          addrs.forEach((addr, i) => {\n            if (this.accounts.indexOf(addr) === -1) {\n              this.accounts.push(addr)\n              this.accountIndices.push(this.unlockedAccount+i)\n            }\n          })\n          return resolve(this.accounts);\n        })\n        .catch((err) => {\n          return reject(new Error(err));\n        })\n      }\n    })\n  }\n\n  // Return the local store of addresses\n  getAccounts() {\n    return Promise.resolve(this.accounts ? this.accounts.slice() : [].slice());\n  }\n\n  signTransaction (address, tx) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address)\n      .then((addrIdx) => {\n        // Build the Lattice request data and make request\n        const txData = {\n          chainId: tx.getChainId() || 1,\n          nonce: Number(`0x${tx.nonce.toString('hex')}`) || 0,\n          gasPrice: Number(`0x${tx.gasPrice.toString('hex')}`),\n          gasLimit: Number(`0x${tx.gasLimit.toString('hex')}`),\n          to: `0x${tx.to.toString('hex')}`,\n          value: Number(`0x${tx.value.toString('hex')}`),\n          data: tx.data.length === 0 ? null : `0x${tx.data.toString('hex')}`,\n          signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, addrIdx],\n        }\n        return this._signTxData(txData)\n      })\n      .then((signedTx) => {\n        // Add the sig params. `signedTx = { sig: { v, r, s }, tx, txHash}`\n        if (!signedTx.sig || !signedTx.sig.v || !signedTx.sig.r || !signedTx.sig.s)\n          return reject(Error('No signature returned'));\n        tx.v = signedTx.sig.v;\n        tx.r = Buffer.from(signedTx.sig.r, 'hex');\n        tx.s = Buffer.from(signedTx.sig.s, 'hex');\n        return resolve(tx);\n      })\n      .catch((err) => {\n        return reject(new Error(err));\n      })\n    })\n  }\n\n  signPersonalMessage(address, msg) {\n    return this.signMessage(address, { payload: msg, protocol: 'signPersonal' });\n  }\n\n  signMessage(address, msg) {\n    return new Promise((resolve, reject) => {\n      this._unlockAndFindAccount(address)\n      .then((addrIdx) => {\n        const { payload, protocol } = msg;\n        if (!payload || !protocol)\n          return reject('`payload` and `protocol` fields must be included in the request');\n        const req = {\n          currency: 'ETH_MSG',\n          data: {\n            protocol,\n            payload,\n            signerPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, addrIdx],\n          }\n        }\n        if (!this._hasSession())\n          return reject('No SDK session started. Cannot sign transaction.')\n        this.sdkSession.sign(req, (err, res) => {\n          if (err)\n            return reject(new Error(err));\n          if (!res.sig)\n            return reject('No signature returned');\n          let v = (res.sig.v - 27).toString(16);\n          if (v.length < 2)\n            v = `0${v}`;\n          return resolve(`0x${res.sig.r}${res.sig.s}${v}`);\n        })\n      })\n    })\n  }\n\n  exportAccount(address) {\n    return Promise.reject(Error('exportAccount not supported by this device'))\n  }\n\n  removeAccount(address) {\n    // We only allow one account at a time, so removing any account\n    // should result in a state reset. The user will need to reconnect\n    // to the Lattice\n    this.forgetDevice();\n  }\n\n  getFirstPage() {\n    this.page = 0;\n    return this._getPage(0);\n  }\n\n  getNextPage () {\n    return this._getPage(1);\n  }\n\n  getPreviousPage () {\n    return this._getPage(-1);\n  }\n\n  setAccountToUnlock (index) {\n    this.unlockedAccount = parseInt(index, 10)\n  }\n\n  forgetDevice () {\n    this._resetDefaults();\n  }\n\n  //-------------------------------------------------------------------\n  // Internal methods and interface to SDK\n  //-------------------------------------------------------------------\n  // Find the account index of the requested address.\n  // Note that this is the BIP39 path index, not the index in the address cache.\n  _unlockAndFindAccount(address) {\n    return new Promise((resolve, reject) => {\n      // NOTE: We are passing `false` here because we do NOT want\n      // state data to be updated as a result of a transaction request.\n      // It is possible the user inserted or removed a SafeCard and\n      // will not be able to sign this transaction. If that is the\n      // case, we just want to return an error message\n      this.unlock(false)\n      .then(() => {\n        return this.getAccounts()\n      })\n      .then((addrs) => {\n        // Find the signer in our current set of accounts\n        // If we can't find it, return an error\n        let addrIdx = null;\n        addrs.forEach((addr, i) => {\n          if (address.toLowerCase() === addr.toLowerCase())\n            addrIdx = i;\n        })\n        if (addrIdx === null)\n          return reject('Signer not present');\n        return resolve(this.accountIndices[addrIdx]);\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n\n  _resetDefaults() {\n    this.accounts = [];\n    this.accountIndices = [];\n    this.isLocked = true;\n    this.creds = {\n      deviceID: null,\n      password: null,\n      endpoint: null,\n    };\n    this.walletUID = null;\n    this.sdkSession = null;\n    this.page = 0;\n    this.unlockedAccount = 0;\n    this.network = null;\n  }\n\n  _getCreds() {\n    return new Promise((resolve, reject) => {\n      // We only need to setup if we don't have a deviceID\n      if (this._hasCreds())\n        return resolve();\n\n      // If we are not aware of what Lattice we should be talking to,\n      // we need to open a window that lets the user go through the\n      // pairing or connection process.\n      const name = this.name ? this.name : 'Unknown'\n      let base = 'https://wallet.gridplus.io';\n      switch (this.network) {\n        case 'rinkeby':\n          base = 'https://gridplus-web-wallet-dev.herokuapp.com';\n          break;\n        default:\n          break;\n      }\n      let url = `${base}?keyring=${name}`;\n      if (this.network)\n        url += `&network=${this.network}`\n      const popup = window.open(url);\n      popup.postMessage('GET_LATTICE_CREDS', base);\n\n      // PostMessage handler\n      function receiveMessage(event) {\n        // Ensure origin\n        if (event.origin !== base)\n          return;\n        // Parse response data\n        try {\n          const data = JSON.parse(event.data);\n          if (!data.deviceID || !data.password)\n            return reject(Error('Invalid credentials returned from Lattice.'));\n          return resolve(data);\n        } catch (err) {\n          return reject(err);\n        }\n      }\n      window.addEventListener(\"message\", receiveMessage, false);\n    })\n  }\n\n  // [re]connect to the Lattice. This should be done frequently to ensure\n  // the expected wallet UID is still the one active in the Lattice.\n  // This will handle SafeCard insertion/removal events.\n  // updateData - true if you want to overwrite walletUID and accounts in\n  //              the event that we find we are not synced.\n  //              If left false and we notice a new walletUID, we will\n  //              return an error.\n  _connect(updateData) {\n    return new Promise((resolve, reject) => {\n      this.sdkSession.connect(this.creds.deviceID, (err) => {\n        if (err)\n          return reject(err);\n        // Save the current wallet UID\n        const activeWallet = this.sdkSession.getActiveWallet();\n        if (!activeWallet || !activeWallet.uid)\n          return reject(\"No active wallet\");\n        const newUID = activeWallet.uid.toString('hex');\n        // If we fetched a walletUID that does not match our current one,\n        // reset accounts and update the known UID\n        if (newUID != this.walletUID) {\n          // If we don't want to update data, return an error\n          if (updateData === false)\n            return reject('Wallet has changed! Please reconnect.')\n          \n          // By default we should clear out accounts and update with\n          // the new walletUID. We should NOT fill in the accounts yet,\n          // as we reserve that functionality to `addAccounts`\n          this.accounts = [];\n          this.walletUID = newUID;\n        }\n        return resolve();\n      });\n    })\n  }\n\n  _initSession() {\n    return new Promise((resolve, reject) => {\n      if (this._hasSession())\n        return resolve();\n      try {\n        let url = 'https://signing.gridpl.us';\n        if (this.network && this.network !== 'mainnet')\n          url = 'https://signing.staging-gridpl.us'\n        if (this.creds.endpoint)\n          url = this.creds.endpoint\n        const setupData = {\n          name: this.name,\n          baseUrl: url,\n          crypto,\n          timeout: 120000,\n          privKey: this._genSessionKey(),\n          network: this.network\n        }\n        this.sdkSession = new SDK.Client(setupData);\n        return resolve();\n      } catch (err) {\n        return reject(err);\n      }\n    })\n  }\n\n  _fetchAddresses(n=1, i=0) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession())\n        return reject('No SDK session started. Cannot fetch addresses.')\n\n      // If we have already cached the address(es), we don't need to do it again\n      if (this.accounts.length > (i + n))\n        return resolve(this.accounts.slice(i, n));\n      \n      // Make the request to get the requested address\n      const addrData = { \n        currency: 'ETH', \n        startPath: [HARDENED_OFFSET+44, HARDENED_OFFSET+60, HARDENED_OFFSET, 0, i], \n        n,\n        skipCache: true\n      }\n      this.sdkSession.getAddresses(addrData, (err, addrs) => {\n        if (err)\n          return reject(Error(`Error getting addresses: ${err}`));\n        // Sanity check -- if this returned 0 addresses, handle the error\n        if (addrs.length < 1)\n          return reject('No addresses returned');\n        // Return the addresses we fetched *without* updating state\n        return resolve(addrs);\n      })\n    })\n  }\n\n  _signTxData(txData) {\n    return new Promise((resolve, reject) => {\n      if (!this._hasSession())\n        return reject('No SDK session started. Cannot sign transaction.')\n      this.sdkSession.sign({ currency: 'ETH', data: txData }, (err, res) => {\n        if (err)\n          return reject(err);\n        if (!res.tx)\n          return reject('No transaction payload returned.');\n        return resolve(res)\n      })\n    })\n  }\n\n  _getPage(increment=0) {\n    return new Promise((resolve, reject) => {\n      this.page += increment;\n      if (this.page < 0)\n        this.page = 0;\n      const start = PER_PAGE * this.page;\n      // Otherwise unlock the device and fetch more addresses\n      this.unlock()\n      .then(() => {\n        return this._fetchAddresses(PER_PAGE, start)\n      })\n      .then((addrs) => {\n        const accounts = []\n        addrs.forEach((address, i) => {\n          accounts.push({\n            address,\n            balance: null,\n            index: start + i,\n          })\n        })\n        return resolve(accounts)\n      })\n      .catch((err) => {\n        return reject(err);\n      })\n    })\n  }\n\n  _hasCreds() {\n    return this.creds.deviceID !== null && this.creds.password !== null && this.name;\n  }\n\n  _hasSession() {\n    return this.sdkSession && this.walletUID;\n  }\n\n  _genSessionKey() {\n    if (!this._hasCreds())\n      throw new Error('No credentials -- cannot create session key!');\n    const buf = Buffer.concat([\n      Buffer.from(this.creds.password), \n      Buffer.from(this.creds.deviceID), \n      Buffer.from(this.name)\n    ])\n    return crypto.createHash('sha256').update(buf).digest();\n  }\n\n}\n\nLatticeKeyring.type = keyringType\nmodule.exports = LatticeKeyring;"]},"metadata":{},"sourceType":"script"}