{"ast":null,"code":"// Util for Bitcoin-specific functionality\nconst bs58 = require('bs58');\n\nconst bs58check = require('bs58check');\n\nconst Buffer = require('buffer/').Buffer;\n\nconst constants = require('./constants');\n\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01\n\nconst {\n  HARDENED_OFFSET\n} = require('./constants');\n\nconst DEFAULT_CHANGE = [44 + HARDENED_OFFSET, HARDENED_OFFSET, HARDENED_OFFSET, 1, 0];\nconst OP = {\n  '0': 0x00,\n  HASH160: 0xa9,\n  DUP: 0x76,\n  EQUAL: 0x87,\n  EQUALVERIFY: 0x88,\n  CHECKSIG: 0xac\n};\nconst addressVersion = {\n  'LEGACY': 0x00,\n  'SEGWIT': 0x05,\n  'TESTNET': 0x6F,\n  'SEGWIT_TESTNET': 0xC4\n};\nexports.addressVersion = addressVersion; // Bitcoin script types -- defined by the Lattice protocol spec\n\nconst scriptTypes = {\n  P2PKH: 0x01,\n  P2SH: 0x02,\n  P2SH_P2WPKH: 0x03\n};\nexports.scriptTypes = scriptTypes; // We need to build two different objects here:\n// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction\n//    with the returned signatures to build and serialize the transaction before\n//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones\n//    we get from the Lattice\n// 2. The serialized Lattice request, which includes data (outlined in the specification)\n//    that is needed to sign all of the inputs and build a change output. \n// @inputs (contained in `data`)\n// `prevOuts`: an array of objects with the following properties:\n//           a. txHash\n//           b. value\n//           c. index          -- the index of the output in the transaction\n//           d. signerPath -- the path of the address in our wallet that is signing this input\n// `recipient`: Receiving address, which must be converted to a pubkeyhash\n// `value`:     Number of satoshis to send the recipient\n// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)\n//              already based on the number of inputs plus two outputs\n// `version`:   Transaction version of the inputs. All inputs must be of the same version! \n// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb\n\nexports.buildBitcoinTxRequest = function (data) {\n  try {\n    const {\n      prevOuts,\n      recipient,\n      value,\n      changePath = DEFAULT_CHANGE,\n      fee,\n      isSegwit,\n      changeVersion = 'SEGWIT'\n    } = data;\n    if (changePath.length !== 5) throw new Error('Please provide a full change path.'); // Serialize the request\n\n    const payload = Buffer.alloc(59 + 69 * prevOuts.length);\n    let off = 0; // Change version byte (a.k.a. address format byte)\n\n    if (addressVersion[changeVersion] === undefined) throw new Error('Invalid change version specified.');\n    payload.writeUInt8(addressVersion[changeVersion]);\n    off++; // Build the change data\n\n    payload.writeUInt32LE(changePath.length, off);\n    off += 4;\n\n    for (let i = 0; i < changePath.length; i++) {\n      payload.writeUInt32LE(changePath[i], off);\n      off += 4;\n    } // Fee is a param\n\n\n    payload.writeUInt32LE(fee, off);\n    off += 4;\n    const recipientVersionByte = bs58.decode(recipient)[0];\n    const recipientPubkeyhash = bs58check.decode(recipient).slice(1); // Parameterize the recipient output\n\n    payload.writeUInt8(recipientVersionByte, off);\n    off++;\n    recipientPubkeyhash.copy(payload, off);\n    off += recipientPubkeyhash.length;\n    writeUInt64LE(value, payload, off);\n    off += 8; // Build the inputs from the previous outputs\n\n    payload.writeUInt8(prevOuts.length, off);\n    off++;\n    let inputSum = 0;\n    const scriptType = isSegwit === true ? scriptTypes.P2SH_P2WPKH : // Only support p2sh(p2wpkh) for segwit spends for now\n    scriptTypes.P2PKH; // No support for multisig p2sh in v1 (p2sh == segwit here)\n\n    prevOuts.forEach(input => {\n      if (!input.signerPath || input.signerPath.length !== 5) {\n        throw new Error('Full recipient path not specified ');\n      }\n\n      payload.writeUInt32LE(input.signerPath.length, off);\n      off += 4;\n\n      for (let i = 0; i < input.signerPath.length; i++) {\n        payload.writeUInt32LE(input.signerPath[i], off);\n        off += 4;\n      }\n\n      payload.writeUInt32LE(input.index, off);\n      off += 4;\n      writeUInt64LE(input.value, payload, off);\n      off += 8;\n      inputSum += input.value;\n      payload.writeUInt8(scriptType, off);\n      off++;\n      if (!Buffer.isBuffer(input.txHash)) input.txHash = Buffer.from(input.txHash, 'hex');\n      input.txHash.copy(payload, off);\n      off += input.txHash.length;\n    }); // Send them back!\n\n    return {\n      payload,\n      schema: constants.signingSchema.BTC_TRANSFER,\n      origData: data,\n      // We will need the original data for serializing the tx\n      changeData: {\n        // This data helps fill in the change output\n        changeVersion,\n        value: inputSum - (value + fee)\n      }\n    };\n  } catch (err) {\n    return {\n      err\n    };\n  }\n}; // Serialize a transaction consisting of inputs, outputs, and some\n// metadata\n// -- inputs  = { hash, index, sig, pubkey }\n// -- outputs = { value, recipient }  // expects an address string for `recipient`\n// -- isSegwitSpend = true if the inputs are being spent using segwit\n//                    (NOTE: either ALL are being spent, or none are)\n// -- network = Name of network, used to determine transaction version\n// -- lockTime = Will probably always be 0\n\n\nexports.serializeTx = function (data) {\n  const {\n    inputs,\n    outputs,\n    isSegwitSpend,\n    lockTime = 0,\n    crypto\n  } = data;\n  let payload = Buffer.alloc(4);\n  let off = 0; // Always use version 2\n\n  const version = 2;\n  payload.writeUInt32LE(version, off);\n  off += 4;\n\n  if (isSegwitSpend === true) {\n    payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00\n\n    payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01\n  } // Serialize signed inputs\n\n\n  const numInputs = getVarInt(inputs.length);\n  payload = concat(payload, numInputs);\n  off += numInputs.length;\n  inputs.forEach(input => {\n    payload = concat(payload, input.hash.reverse());\n    off += input.hash.length;\n    const index = getU32LE(input.index);\n    payload = concat(payload, index);\n    off += index.length;\n\n    if (isSegwitSpend === true) {\n      // Build a vector (varSlice of varSlice) containing the redeemScript\n      const redeemScript = buildRedeemScript(input.pubkey, crypto);\n      const redeemScriptLen = getVarInt(redeemScript.length);\n      const slice = Buffer.concat([redeemScriptLen, redeemScript]);\n      const sliceLen = getVarInt(slice.length);\n      payload = concat(payload, sliceLen);\n      off += sliceLen.length;\n      payload = concat(payload, slice);\n      off += slice.length;\n    } else {\n      // Build the signature + pubkey script to spend this input\n      const slice = buildSig(input.sig, input.pubkey);\n      payload = concat(payload, slice);\n      off += slice.length;\n    } // Use the default sequence for all transactions\n\n\n    const sequence = getU32LE(DEFAULT_SEQUENCE);\n    payload = concat(payload, sequence);\n    off += sequence.length;\n  }); // Serialize outputs\n\n  const numOutputs = getVarInt(outputs.length);\n  payload = concat(payload, numOutputs);\n  off += numOutputs.length;\n  outputs.forEach(output => {\n    const value = getU64LE(output.value);\n    payload = concat(payload, value);\n    off += value.length; // Build the output locking script and write it as a var slice\n\n    const script = buildLockingScript(output.recipient);\n    const scriptLen = getVarInt(script.length);\n    payload = concat(payload, scriptLen);\n    off += scriptLen.length;\n    payload = concat(payload, script);\n    off += script.length;\n  }); // Add witness data if needed\n\n  if (isSegwitSpend === true) {\n    const sigs = [];\n    const pubkeys = [];\n\n    for (let i = 0; i < inputs.length; i++) {\n      sigs.push(inputs[i].sig);\n      pubkeys.push(inputs[i].pubkey);\n    }\n\n    const witnessSlice = buildWitness(sigs, pubkeys);\n    payload = concat(payload, witnessSlice);\n    off += witnessSlice.length;\n  } // Finish with locktime\n\n\n  return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');\n}; // Convert a pubkeyhash to a bitcoin base58check address with a version byte\n\n\nexports.getBitcoinAddress = function (pubkeyhash, version) {\n  return bs58check.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));\n}; // Builder utils\n//-----------------------\n\n\nfunction buildRedeemScript(pubkey, crypto) {\n  const redeemScript = Buffer.alloc(22);\n  const shaHash = crypto.createHash('sha256').update(pubkey).digest();\n  const pubkeyhash = crypto.createHash('rmd160').update(shaHash).digest();\n  redeemScript.writeUInt8(OP['0']);\n  redeemScript.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(redeemScript, 2);\n  return redeemScript;\n} // Var slice of signature + var slice of pubkey\n\n\nfunction buildSig(sig, pubkey) {\n  sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER]);\n  const sigLen = getVarInt(sig.length);\n  const pubkeyLen = getVarInt(pubkey.length);\n  const slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);\n  const len = getVarInt(slice.length);\n  return Buffer.concat([len, slice]);\n} // Witness is written as a \"vector\", which is a list of varSlices\n// prefixed by the number of items\n\n\nfunction buildWitness(sigs, pubkeys) {\n  let witness = Buffer.alloc(0); // Two items in each vector (sig, pubkey)\n\n  const len = Buffer.alloc(1);\n  len.writeUInt8(2);\n\n  for (let i = 0; i < sigs.length; i++) {\n    const sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);\n    const sigLen = getVarInt(sig.length);\n    const pubkey = pubkeys[i];\n    const pubkeyLen = getVarInt(pubkey.length);\n    witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);\n  }\n\n  return witness;\n} // Locking script buiders\n//-----------------------\n\n\nfunction buildLockingScript(address) {\n  const versionByte = bs58.decode(address)[0];\n  const pubkeyhash = bs58check.decode(address).slice(1);\n\n  if (versionByte === addressVersion.SEGWIT || versionByte === addressVersion.SEGWIT_TESTNET) {\n    // Also works for p2sh\n    return buildP2shLockingScript(pubkeyhash);\n  } else {\n    // We assume testnet uses p2pkh\n    return buildP2pkhLockingScript(pubkeyhash);\n  }\n}\n\nfunction buildP2pkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(5 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.DUP, off);\n  off++;\n  out.writeUInt8(OP.HASH160, off);\n  off++;\n  out.writeUInt8(pubkeyhash.length, off);\n  off++;\n  pubkeyhash.copy(out, off);\n  off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUALVERIFY, off);\n  off++;\n  out.writeUInt8(OP.CHECKSIG, off);\n  off++;\n  return out;\n}\n\nfunction buildP2shLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(3 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.HASH160, off);\n  off++;\n  out.writeUInt8(pubkeyhash.length, off);\n  off++;\n  pubkeyhash.copy(out, off);\n  off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUAL, off);\n  off++;\n  return out;\n} // Static Utils\n//----------------------\n\n\nfunction concat(base, addition) {\n  return Buffer.concat([base, addition]);\n}\n\nfunction getU64LE(x) {\n  const buffer = Buffer.alloc(8);\n  writeUInt64LE(x, buffer, 0);\n  return buffer;\n}\n\nfunction getU32LE(x) {\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32LE(x);\n  return buffer;\n}\n\nfunction getVarInt(x) {\n  let buffer;\n\n  if (x < 0xfd) {\n    buffer = Buffer.alloc(1);\n    buffer.writeUInt8(x);\n  } else if (x <= 0xffff) {\n    buffer = Buffer.alloc(3);\n    buffer.writeUInt8(0xfd, 0);\n    buffer.writeUInt16LE(x, 1);\n  } else if (x < 0xffffffff) {\n    buffer = Buffer.alloc(5);\n    buffer.writeUInt8(0xfe, 0);\n    buffer.writeUInt32LE(x, 1);\n  } else {\n    buffer = Buffer.alloc(9);\n    buffer.writeUInt8(0xff, 0);\n    buffer.writeUInt32LE(x >>> 0, 1);\n    buffer.writeUInt32LE(x / 0x100000000 | 0, 5);\n  }\n\n  return buffer;\n}\n\nfunction writeUInt64LE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.reverse().copy(preBuf, 0);\n  preBuf.copy(buf, off);\n  return preBuf;\n}","map":{"version":3,"sources":["/Users/leondo/Desktop/metamask-auth/node_modules/gridplus-sdk/src/bitcoin.js"],"names":["bs58","require","bs58check","Buffer","constants","DEFAULT_SEQUENCE","DEFAULT_SIGHASH_BUFFER","from","HARDENED_OFFSET","DEFAULT_CHANGE","OP","HASH160","DUP","EQUAL","EQUALVERIFY","CHECKSIG","addressVersion","exports","scriptTypes","P2PKH","P2SH","P2SH_P2WPKH","buildBitcoinTxRequest","data","prevOuts","recipient","value","changePath","fee","isSegwit","changeVersion","length","Error","payload","alloc","off","undefined","writeUInt8","writeUInt32LE","i","recipientVersionByte","decode","recipientPubkeyhash","slice","copy","writeUInt64LE","inputSum","scriptType","forEach","input","signerPath","index","isBuffer","txHash","schema","signingSchema","BTC_TRANSFER","origData","changeData","err","serializeTx","inputs","outputs","isSegwitSpend","lockTime","crypto","version","concat","numInputs","getVarInt","hash","reverse","getU32LE","redeemScript","buildRedeemScript","pubkey","redeemScriptLen","sliceLen","buildSig","sig","sequence","numOutputs","output","getU64LE","script","buildLockingScript","scriptLen","sigs","pubkeys","push","witnessSlice","buildWitness","toString","getBitcoinAddress","pubkeyhash","encode","shaHash","createHash","update","digest","sigLen","pubkeyLen","len","witness","address","versionByte","SEGWIT","SEGWIT_TESTNET","buildP2shLockingScript","buildP2pkhLockingScript","out","base","addition","x","buffer","writeUInt16LE","n","buf","preBuf","nStr","nBuf"],"mappings":"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","sourcesContent":["// Util for Bitcoin-specific functionality\nconst bs58 = require('bs58');\nconst bs58check = require('bs58check')\nconst Buffer = require('buffer/').Buffer;\nconst constants = require('./constants')\nconst DEFAULT_SEQUENCE = 0xffffffff;\nconst DEFAULT_SIGHASH_BUFFER = Buffer.from('01', 'hex'); // SIGHASH_ALL = 0x01\nconst { HARDENED_OFFSET } = require('./constants');\nconst DEFAULT_CHANGE = [44 + HARDENED_OFFSET, HARDENED_OFFSET, HARDENED_OFFSET, 1, 0];\n\nconst OP = {\n  '0': 0x00,\n  HASH160: 0xa9,\n  DUP: 0x76,\n  EQUAL: 0x87,\n  EQUALVERIFY: 0x88,\n  CHECKSIG: 0xac,\n}\n\nconst addressVersion = {\n  'LEGACY': 0x00,\n  'SEGWIT': 0x05,\n  'TESTNET': 0x6F,\n  'SEGWIT_TESTNET': 0xC4,\n}\nexports.addressVersion = addressVersion;\n\n// Bitcoin script types -- defined by the Lattice protocol spec\nconst scriptTypes = {\n  P2PKH: 0x01,\n  P2SH: 0x02,\n  P2SH_P2WPKH: 0x03,\n}\nexports.scriptTypes = scriptTypes\n\n// We need to build two different objects here:\n// 1. bitcoinjs-lib TransactionBuilder object, which will be used in conjunction\n//    with the returned signatures to build and serialize the transaction before\n//    broadcasting it. We will replace `bitcoinjs-lib`'s signatures with the ones\n//    we get from the Lattice\n// 2. The serialized Lattice request, which includes data (outlined in the specification)\n//    that is needed to sign all of the inputs and build a change output. \n// @inputs (contained in `data`)\n// `prevOuts`: an array of objects with the following properties:\n//           a. txHash\n//           b. value\n//           c. index          -- the index of the output in the transaction\n//           d. signerPath -- the path of the address in our wallet that is signing this input\n// `recipient`: Receiving address, which must be converted to a pubkeyhash\n// `value`:     Number of satoshis to send the recipient\n// `fee`:       Number of satoshis to use for a transaction fee (should have been calculated)\n//              already based on the number of inputs plus two outputs\n// `version`:   Transaction version of the inputs. All inputs must be of the same version! \n// `isSegwit`: a boolean which determines how we serialize the data and parameterize txb\nexports.buildBitcoinTxRequest = function(data) {\n  try {\n    const { prevOuts, recipient, value, changePath=DEFAULT_CHANGE, fee, isSegwit, changeVersion='SEGWIT' } = data;\n    if (changePath.length !== 5) throw new Error('Please provide a full change path.')\n    // Serialize the request\n    const payload = Buffer.alloc(59 + (69 * prevOuts.length));\n    let off = 0;\n    // Change version byte (a.k.a. address format byte)\n    if (addressVersion[changeVersion] === undefined)\n      throw new Error('Invalid change version specified.');\n    payload.writeUInt8(addressVersion[changeVersion]); off++;\n\n    // Build the change data\n    payload.writeUInt32LE(changePath.length, off); off += 4;\n    for (let i = 0; i < changePath.length; i++) {\n      payload.writeUInt32LE(changePath[i], off); off += 4;\n    }    \n\n    // Fee is a param\n    payload.writeUInt32LE(fee, off); off += 4;\n    const recipientVersionByte = bs58.decode(recipient)[0];\n    const recipientPubkeyhash = bs58check.decode(recipient).slice(1);\n    // Parameterize the recipient output\n    payload.writeUInt8(recipientVersionByte, off); off++;\n    recipientPubkeyhash.copy(payload, off); off += recipientPubkeyhash.length;\n    writeUInt64LE(value, payload, off); off += 8;\n\n    // Build the inputs from the previous outputs\n    payload.writeUInt8(prevOuts.length, off); off++;\n    let inputSum = 0;\n    const scriptType = isSegwit === true ? \n                        scriptTypes.P2SH_P2WPKH :  // Only support p2sh(p2wpkh) for segwit spends for now\n                        scriptTypes.P2PKH; // No support for multisig p2sh in v1 (p2sh == segwit here)\n    prevOuts.forEach((input) => {\n      if (!input.signerPath || input.signerPath.length !== 5) {\n        throw new Error('Full recipient path not specified ')\n      }\n      payload.writeUInt32LE(input.signerPath.length, off); off += 4;\n      for (let i = 0; i < input.signerPath.length; i++) {\n        payload.writeUInt32LE(input.signerPath[i], off); off += 4;\n      }\n      payload.writeUInt32LE(input.index, off); off += 4;\n      writeUInt64LE(input.value, payload, off); off += 8;\n      inputSum += input.value;\n      payload.writeUInt8(scriptType, off); off++;\n      if (!Buffer.isBuffer(input.txHash)) input.txHash = Buffer.from(input.txHash, 'hex');\n      input.txHash.copy(payload, off); off += input.txHash.length;\n    })\n    // Send them back!\n    return {\n      payload,\n      schema: constants.signingSchema.BTC_TRANSFER,\n      origData: data,   // We will need the original data for serializing the tx\n      changeData: {     // This data helps fill in the change output\n        changeVersion,\n        value: inputSum - (value + fee),\n      }\n    };\n  } catch (err) {\n    return { err };\n  }\n}\n\n// Serialize a transaction consisting of inputs, outputs, and some\n// metadata\n// -- inputs  = { hash, index, sig, pubkey }\n// -- outputs = { value, recipient }  // expects an address string for `recipient`\n// -- isSegwitSpend = true if the inputs are being spent using segwit\n//                    (NOTE: either ALL are being spent, or none are)\n// -- network = Name of network, used to determine transaction version\n// -- lockTime = Will probably always be 0\nexports.serializeTx = function(data) {\n  const { inputs, outputs, isSegwitSpend, lockTime=0, crypto } = data;\n  let payload = Buffer.alloc(4);\n  let off = 0;\n  // Always use version 2\n  const version = 2;\n  payload.writeUInt32LE(version, off); off += 4;\n  if (isSegwitSpend === true) {\n    payload = concat(payload, Buffer.from('00', 'hex')); // marker = 0x00\n    payload = concat(payload, Buffer.from('01', 'hex')); // flag = 0x01\n  }\n  // Serialize signed inputs\n  const numInputs = getVarInt(inputs.length);\n  payload = concat(payload, numInputs); off += numInputs.length;\n  inputs.forEach((input) => {\n    payload = concat(payload, input.hash.reverse()); off += input.hash.length;\n    const index = getU32LE(input.index);\n    payload = concat(payload, index); off += index.length;\n    if (isSegwitSpend === true) {\n      // Build a vector (varSlice of varSlice) containing the redeemScript\n      const redeemScript = buildRedeemScript(input.pubkey, crypto);\n      const redeemScriptLen = getVarInt(redeemScript.length);\n      const slice = Buffer.concat([redeemScriptLen, redeemScript]);\n      const sliceLen = getVarInt(slice.length);\n      payload = concat(payload, sliceLen); off += sliceLen.length;\n      payload = concat(payload, slice); off += slice.length;\n    } else {\n      // Build the signature + pubkey script to spend this input\n      const slice = buildSig(input.sig, input.pubkey);\n      payload = concat(payload, slice); off += slice.length;\n    }\n    // Use the default sequence for all transactions\n    const sequence = getU32LE(DEFAULT_SEQUENCE);\n    payload = concat(payload, sequence); off += sequence.length;\n  })\n  // Serialize outputs\n  const numOutputs = getVarInt(outputs.length);\n  payload = concat(payload, numOutputs); off += numOutputs.length;\n  outputs.forEach((output) => {\n    const value = getU64LE(output.value);\n    payload = concat(payload, value); off += value.length;\n    // Build the output locking script and write it as a var slice\n    const script = buildLockingScript(output.recipient);\n    const scriptLen = getVarInt(script.length);\n    payload = concat(payload, scriptLen); off += scriptLen.length;\n    payload = concat(payload, script); off += script.length;\n  })\n  // Add witness data if needed\n  if (isSegwitSpend === true) {\n    const sigs = [];\n    const pubkeys = [];\n    for (let i = 0; i < inputs.length; i++) {\n      sigs.push(inputs[i].sig);\n      pubkeys.push(inputs[i].pubkey);\n    }\n    const witnessSlice = buildWitness(sigs, pubkeys);\n    payload = concat(payload, witnessSlice); off += witnessSlice.length;\n  }\n  // Finish with locktime\n  return Buffer.concat([payload, getU32LE(lockTime)]).toString('hex');\n}\n\n// Convert a pubkeyhash to a bitcoin base58check address with a version byte\nexports.getBitcoinAddress = function(pubkeyhash, version) {\n  return bs58check.encode(Buffer.concat([Buffer.from([version]), pubkeyhash]));\n}\n\n\n// Builder utils\n//-----------------------\nfunction buildRedeemScript(pubkey, crypto) {\n  const redeemScript = Buffer.alloc(22);\n  const shaHash = crypto.createHash('sha256').update(pubkey).digest();\n  const pubkeyhash = crypto.createHash('rmd160').update(shaHash).digest();\n  redeemScript.writeUInt8(OP['0']);\n  redeemScript.writeUInt8(pubkeyhash.length, 1);\n  pubkeyhash.copy(redeemScript, 2);\n  return redeemScript;\n}\n\n// Var slice of signature + var slice of pubkey\nfunction buildSig(sig, pubkey) {\n  sig = Buffer.concat([sig, DEFAULT_SIGHASH_BUFFER])\n  const sigLen = getVarInt(sig.length);\n  const pubkeyLen = getVarInt(pubkey.length);\n  const slice = Buffer.concat([sigLen, sig, pubkeyLen, pubkey]);\n  const len = getVarInt(slice.length);\n  return Buffer.concat([len, slice]);\n}\n\n// Witness is written as a \"vector\", which is a list of varSlices\n// prefixed by the number of items\nfunction buildWitness(sigs, pubkeys) {\n  let witness = Buffer.alloc(0);\n  // Two items in each vector (sig, pubkey)\n  const len = Buffer.alloc(1); len.writeUInt8(2);\n  for (let i = 0; i < sigs.length; i++) {\n    const sig = Buffer.concat([sigs[i], DEFAULT_SIGHASH_BUFFER]);\n    const sigLen = getVarInt(sig.length);\n    const pubkey = pubkeys[i];\n    const pubkeyLen = getVarInt(pubkey.length);\n    witness = Buffer.concat([witness, len, sigLen, sig, pubkeyLen, pubkey]);\n  }\n  return witness;\n}\n\n// Locking script buiders\n//-----------------------\nfunction buildLockingScript(address) {\n  const versionByte = bs58.decode(address)[0];\n  const pubkeyhash = bs58check.decode(address).slice(1);\n  if (versionByte === addressVersion.SEGWIT || versionByte === addressVersion.SEGWIT_TESTNET) { \n    // Also works for p2sh\n    return buildP2shLockingScript(pubkeyhash);\n  } else {\n    // We assume testnet uses p2pkh\n    return buildP2pkhLockingScript(pubkeyhash);\n  }\n}\n\nfunction buildP2pkhLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(5 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.DUP, off); off++;\n  out.writeUInt8(OP.HASH160, off); off++;\n  out.writeUInt8(pubkeyhash.length, off); off++;\n  pubkeyhash.copy(out, off); off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUALVERIFY, off); off++;\n  out.writeUInt8(OP.CHECKSIG, off); off++;\n  return out;\n}\n\nfunction buildP2shLockingScript(pubkeyhash) {\n  const out = Buffer.alloc(3 + pubkeyhash.length);\n  let off = 0;\n  out.writeUInt8(OP.HASH160, off); off++;\n  out.writeUInt8(pubkeyhash.length, off); off++;\n  pubkeyhash.copy(out, off); off += pubkeyhash.length;\n  out.writeUInt8(OP.EQUAL, off); off++;\n  return out;\n}\n\n// Static Utils\n//----------------------\nfunction concat(base, addition) {\n  return Buffer.concat([base, addition]);\n}\n\nfunction getU64LE(x) {\n  const buffer = Buffer.alloc(8);\n  writeUInt64LE(x, buffer, 0);\n  return buffer;\n}\n\nfunction getU32LE(x) {\n  const buffer = Buffer.alloc(4);\n  buffer.writeUInt32LE(x);\n  return buffer;\n}\n\nfunction getVarInt (x) {\n  let buffer;\n  if (x < 0xfd) {\n    buffer = Buffer.alloc(1);\n    buffer.writeUInt8(x);\n  } else if (x <= 0xffff) {\n    buffer = Buffer.alloc(3);\n    buffer.writeUInt8(0xfd, 0);\n    buffer.writeUInt16LE(x, 1);\n  } else if (x < 0xffffffff) {\n    buffer = Buffer.alloc(5);\n    buffer.writeUInt8(0xfe, 0);\n    buffer.writeUInt32LE(x, 1);\n  } else {\n    buffer = Buffer.alloc(9);\n    buffer.writeUInt8(0xff, 0);\n    buffer.writeUInt32LE(x >>> 0, 1);\n    buffer.writeUInt32LE((x / 0x100000000) | 0, 5);\n  }\n  return buffer;\n}\n\nfunction writeUInt64LE(n, buf, off) {\n  if (typeof n === 'number') n = n.toString(16);\n  const preBuf = Buffer.alloc(8);\n  const nStr = n.length % 2 === 0 ? n.toString(16) : `0${n.toString(16)}`;\n  const nBuf = Buffer.from(nStr, 'hex');\n  nBuf.reverse().copy(preBuf, 0);\n  preBuf.copy(buf, off);\n  return preBuf;\n}"]},"metadata":{},"sourceType":"script"}